#!/usr/bin/perl

###################################################################
#
#   The purpose of this script is to generate a CSV report
#   in a specific format.
#   The input are taken from the CSV generated by scripts of
#   the VM reporting suite.
#
###################################################################

use strict;
use JavaExecution;

# Local constants
use constant REPORT_NAME              => "/opt/global/perf/moip/aggregated/reports/vvs/VM-FinalReport-<TIMESTAMP>.csv";
use constant INBOX_REPORT_FILE        => "./VM-Counter-Reports_Inbox.csv";
use constant ACTIVE_INBOX_REPORT_FILE => "./VM-Counter-Reports_ActiveInbox.csv";
use constant COUNTERS_REPORT_FILE     => "./VM-Counter-Reports_Counters.csv";
use constant IMAP_REPORTER_PATH       => "/opt/msgcore/imapreporter";


# Development specifics
use constant DEBUG => 0;
use constant SIMUL => 0;

# Local sub-routines
sub createToFile;
sub saveToFile;
sub formatDate;
sub reportNumberOfInboxes;
sub isDateRangeComplete;
sub readTopology;
sub syntax;

# Month Conversion
my @monthTable =
  ( "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" );
my @monthsize = (31,28,31,30,31,30,31,31,30,31,30,31);

# Counter name conversion
my %counterNames = (
 "NumberOfSecondsReturnCalls"    => "Number of voicemail minutes for Call Returns",
 "NumberOfSecondsRetrievalCalls" => "Number of voicemail minutes for Call Retrieval",
 "NumberOfSecondsDepositCalls"   => "Number of voicemail minutes for Deposit Calls",
 "NumberOfSecondsOutdialNotif"   => "Number of voicemail minutes for Outdial Notification",
 "NumberOfReturnCalls"           => "Number of voicemail Call Returns",
 "NumberOfSlamdowns"             => "Number of Slamdown calls",
 "NumberOfDepositCalls"          => "Number of Deposit Calls",
 "NumberOfOutdialNotif"          => "Number of Outdial Notification"
);

# Sanity check
sub getServerType {
    #read serverType from /etc/hosttype.
    #return this value

    open(my $fh, "/etc/hosttype");
    my $serverType="";
    my $line="";
    my @serverList = <$fh>;
    close($fh);
    ($serverType)=@serverList;
    chomp $serverType;
    return uc $serverType;
}

if ( !SIMUL ) {

 my $host = $ENV{HOSTNAME};
 my $servertype=getServerType($host);

 if ( $servertype !~ /OM/ ) {
  print "The script must run on a node of type OM. We are currently on the " .  $host . " node, of type $servertype\n";
  exit 1;
 }
}

my $isDetail = 0;
my $detailPath = "";
my $defaultDetailPath = "/opt/moip/reports/vvmDetailSub";

if ($ARGV[scalar(@ARGV)-1] =~ m/detail=(.+)/){
        $isDetail = 1;
        $detailPath = $1;
} elsif ($ARGV[scalar(@ARGV)-1] == "detail"){
        $isDetail = 1;
        $detailPath = $defaultDetailPath;
} else {
   $detailPath = $defaultDetailPath;
}

if ($isDetail){
        pop(@ARGV);
}

# Check the input parameters first. See syntax.
if ( scalar(@ARGV) == 0 || scalar(@ARGV) > 2 ) {
 syntax();
 exit;
}

# Format the date for the request <year><month>
my $date = $ARGV[0];
my @datearray;
if ( length($date) < 6 ) {
 @datearray = localtime();
 $date = sprintf( "%04d%02d", ( 1900 + $datearray[5] ), $ARGV[0] );
}
if (DEBUG) {
 print("Report for $date\n");
}
@datearray = formatDate( $date . "01" );
if (DEBUG) {
 print("Report for $datearray[2] $datearray[1] $datearray[0]\n");
}
# Get the delay value.
my $delay_for_active = 0;
if(scalar(@ARGV) == 2){
 $delay_for_active = $ARGV[1];
} else {
 my $index = substr($date,4,2);
 $delay_for_active = $monthsize[$index - 1];
}

# Global declarations
my @reports = ();
my %abs_opcolist     = ();    # <opco><.>   The absolute list of opco
my %abs_sitelist     = ();    # <site><.>   The absolute list of site

# These 4 arrays are filled by the subroutine readTopology()
my @opcoList;
my @remoteSiteList;
my @localSiteName;
my @remoteSiteNames;
readTopology();

my @allSites = @localSiteName;
push(@allSites, @remoteSiteNames);
if (DEBUG) {
 foreach my $item (@opcoList){
  print "opco = $item\n";
 }
 foreach my $item (@remoteSiteList){
  print "remote site = $item\n";
 }
 foreach my $item (@localSiteName){
  print "local site name = $item\n";
 }
 foreach my $item (@remoteSiteNames){
  print "remote site name = $item\n";
 }
 foreach my $item (@allSites){
  print "site name = $item\n";
 }
 exit;
}

# Create the report name with a timestamp like 20100717.0800
my @datearrayname = localtime();
my $datename = sprintf( "%s-%s-%04d%02d%02d.%02d%02d", ($datearray[1], $datearray[0], 1900 + $datearrayname[5] ), 1 + $datearrayname[4], $datearrayname[3], $datearrayname[2], $datearrayname[1] );

my $reportfilename = REPORT_NAME;
$reportfilename =~ s/<TIMESTAMP>/$datename/;

# Generating the header
#VVS-Counters Reporting
#Month: September 2010
createToFile( $reportfilename, "VVS Counters Reporting\n", "Month: $datearray[1] $datearray[0]\n", "\n" );

# Report the counters
reportCounters( $reportfilename, COUNTERS_REPORT_FILE );

# Report on the Total Number of Inboxes
reportNumberOfInboxes( $reportfilename, INBOX_REPORT_FILE );

# Report on the Total Number of Inboxes
reportAccurateNumberOfActiveInboxes( $reportfilename );

## END OF MAIN ############################################

##############################################################################
sub createToFile {
 my ( $filename, @content ) = @_;
 open FILE, ">$filename" || die "ERROR Trying to open the file $filename. Verify permissions on the folder";
 foreach my $line (@content) {
  print FILE $line;
 }
 close FILE;
}

##############################################################################
sub saveToFile {
 my ( $filename, @content ) = @_;
 open FILE, ">>$filename" || die "ERROR Trying to open the file $filename. Verify permissions on the folder";
 foreach my $line (@content) {
  print FILE $line;
 }
 close FILE;
}

##############################################################################
sub readFileContent {
 my ($filename) = @_;
 my @content = ();
 open FILE, $filename || die "Cannot open $filename. Exiting\n";
 while (<FILE>) {
  push @content, $_;
 }
 close FILE;
 chomp(@content);
 return @content;
}

##############################################################################
sub readTopology() {
    my $imapreporterjar = IMAP_REPORTER_PATH . "/imapreporter_component.jar";
    @opcoList = JavaExecution::javaExec("$imapreporterjar listOpco -service moip -productPrefix moip");
	@remoteSiteList = JavaExecution::javaExec("$imapreporterjar listRemoteSites -service moip -productPrefix moip");
	@localSiteName = JavaExecution::javaExec("$imapreporterjar getLocalSiteName -service moip -productPrefix moip");
	@remoteSiteNames = JavaExecution::javaExec("$imapreporterjar getRemoteSiteNames -service moip -productPrefix moip");
}

##############################################################################
sub syntax() {
 print("Syntax:\n\t$0 <month> <active_inbox_delay>\n");
 print("\tAll parameters must be numeric.\n");
 print("\t<month>              The month requested.\n");
 print("\t<active_inbox_delay> The number of days for the active inbox.\n");
 print("Example:\n\t$0 9 20    # For September current year \n");
}

##############################################################################
# Translate a numeric date into user friendly format
# 20100908    2010 September 08
# 201009      2010 September
# Returns an array (year, month,day)
sub formatDate {
 my ($date) = @_;
 if ( !$date =~ m/^d+$/ or length($date) != 8 ) {
  return ( "", "", "" );
 }
 my $year  = substr( $date, 0, 4 );
 my $month = substr( $date, 4, 2 );
 $month = $monthTable[ $month - 1 ];
 my $day = "";
 if ( length($date) == 8 ) {
  $day = substr( $date, 6, 2 );
 }
 return ( $year, $month, $day );
}

##############################################################################
# Translate a numeric date into user friendly format
# 20100908    2010 September 08
# 201009      2010 September
# Returns an array (year, month,day)
sub getDateToPrint {
 my ($date) = @_;
 my ( $year, $month, $day ) = formatDate($date);
 return sprintf( "%02s %s %s", $day, $month, $year );
}

##############################################################################
my %siteopco = ();
my ( %opcolist, %sitelist );    # <name><nb>

##############################################################################
# Generate the Number of Inboxes report part
# Expected input format:
#  site=SA2B0
#  opco1=0,opco2=4,
#  site=SA2B1
#  opco2=4,
#  site=SA2B7
#  opco8=0,opco2=4,
sub reportNumberOfInboxes {
 my ( $out, $inputfilename ) = @_;
 my $currentsite;
 my @content = readFileContent($inputfilename);
 my @temp;

 # Init of the common variables
 %siteopco = ();
 %opcolist = ();
 %sitelist = ();

 # Create multiple hash in format:
 # %siteopco -> <site|opco><nb>
 # %sitelist -> <site><nb>
 # %opcolist -> <opco><nb>
 foreach my $line (@content) {
  $line =~ s/\s+//g;
  if ( $line =~ m/^site/ ) {
   @temp = split( "=", $line );
   $currentsite = $temp[1];
   if (DEBUG) {
    print "reportNumberOfInboxes() currentsite = $currentsite\n";
   }
  }
  else {
   my @opcos = split( ",", $line );
   foreach my $opcovalue (@opcos) {
    my ( $opco, $nb ) = split( "=", $opcovalue );
    if (DEBUG) {
     print "reportNumberOfInboxes() currentsite = $currentsite, $opco = $nb\n";
    }
    my $key      = "${currentsite}|${opco}";
    my $newvalue = $nb;
    $newvalue += $siteopco{$key} if ( exists( $siteopco{$key} ) );
    $siteopco{$key} = $newvalue;
    $newvalue = $nb;
    $newvalue += $opcolist{$opco} if ( exists( $opcolist{$opco} ) );
    $opcolist{$opco} = $newvalue;
    $newvalue = $nb;
    $newvalue += $sitelist{$currentsite} if ( exists( $sitelist{$currentsite} ) );
    $sitelist{$currentsite} = $newvalue;
   }
  }
 }

 # Now print the table please
 my $message = "Total number of inboxes provisioned
Note:,The numbers represent the total cumulated since the original installation.
 ,The values are updated once every 24 hours.\n";
 genericTableDataOutput( $out, $message, 0);  # No horizontal total
}

##############################################################################
# Generate the Number of Active Inboxes report part
# Expected input format:
#  site = SA2B7
#  opco = opco8
#  activeVmInbox = 3
#  site = SA2B1
#  opco = opco2
#  activeVmInbox = 4
#  site = SA2B0
#  opco = opco1
#  activeVmInbox = 250
#  opco = opco2
#  activeVmInbox = 4
sub reportNumberOfActiveInboxes {
   my ( $out, $inputfilename ) = @_;
   my ( $currentsite, $currentopco );
   my @content = readFileContent($inputfilename);
   my @temp;

   # Init of the common variables
   %siteopco = ();
   %opcolist = ();
   %sitelist = ();

   # Create multiple hash in format:
   # %siteopco -> <site|opco><nb>
   # %sitelist -> <site><nb>
   # %opcolist -> <opco><nb>
   foreach my $line (@content) {
    $line =~ s/\s+//g;
    if ( $line =~ m/^site/ ) {
     @temp = split( "=", $line );
     $currentsite = $temp[1];
     if (DEBUG) {
      print "reportNumberOfActiveInboxes() currentsite=$currentsite\n";
     }
    }
    elsif ( $line =~ m/^opco/ ) {
     @temp = split( "=", $line );
     $currentopco = $temp[1];
     if (DEBUG) {
      print "reportNumberOfActiveInboxes() currentsite=$currentsite currentopco=$currentopco\n";
     }
    }
    elsif ( ( $line =~ m/^activeVmInbox/ ) ) {
     my @temp = split( "=", $line );
     my $nb = $temp[1];
     if (DEBUG) {
      print "reportNumberOfInboxes() currentsite=$currentsite currentopco=$currentopco activeVmInbox=$nb\n";
     }
     my $key      = "${currentsite}|${currentopco}";
     my $newvalue = $nb;
     $newvalue += $siteopco{$key} if ( exists( $siteopco{$key} ) );
     $siteopco{$key} = $newvalue;
     $newvalue = $nb;
     $newvalue += $opcolist{$currentopco} if ( exists( $opcolist{$currentopco} ) );
     $opcolist{$currentopco} = $newvalue;
     $newvalue = $nb;
     $newvalue += $sitelist{$currentsite} if ( exists( $sitelist{$currentsite} ) );
     $sitelist{$currentsite} = $newvalue;
    }
   }

   # Now print the table please
   genericTableDataOutput( $out, "Total number of active Voicemail inboxes\nNote:,For the last $delay_for_active days.\n", 1 );
}


###########################################################################################
# Generate the Accurate Number of Active Inboxes report from detailed subscriber files
# Input filename format:
# 		$detailPath/$opco/moip/vvmSubDetail/imapReportSubDetail-$siteName-$opco.txt
# 		$detailPath/imapReportSubDetail-$siteName-$opco.txt
sub reportAccurateNumberOfActiveInboxes {
   my $out = $_[0];
   
   # Move local detail sub files for each opco to $detailPath directory, easy for further analysis
   my $mvCommand = "mv";
   foreach(@opcoList){
   	my $localDetailFile = "/opt/global/perf/$_/moip/vvmDetailSub/imapReportSubDetail-$localSiteName[0]-$_.txt";
   	if(-e $localDetailFile){
   		$mvCommand = "mv /opt/global/perf/$_/moip/vvmDetailSub/imapReportSubDetail*.txt $detailPath/";
   		`$mvCommand`;
 	 	if ($? != 0){
 	 		print "Failded to move file /opt/global/perf/$_/moip/vvmDetailSub/imapReportSubDetail*.txt to $detailPath/. VVM Active subscriber report might be inaccurate.";
 	 	}		
	}		
   }
 	 
   my $currentOpco;
   my $currentSite;
   my $currentCmd;

   my $totalSum = 0;
   my $result;

   chomp(@opcoList);
   chomp(@allSites);

   # Print the title and site list as header
   saveToFile( $out, "Total number of active Voicemail inboxes\nNote:,For the last $delay_for_active days.\n", "opco\\site, " );
   foreach(sort @allSites){
   	saveToFile( $out, "$_,");
   }
   saveToFile( $out, ",Total:\n" );
   
   # Print opco: xx, xx, xx, xx, totalnumForOpco
   foreach $currentOpco (sort @opcoList){
		saveToFile( $out, "$currentOpco,");
    foreach $currentSite (sort @allSites) {
	$currentCmd = "cat $detailPath/imapReportSubDetail-$currentSite-$currentOpco.txt 2>null | wc -l";
    	$result = `$currentCmd`; 
	chomp($result);
	if (DEBUG){ 
		print "opco: $currentOpco; site: $currentSite --------- count: $result\n";
	}
    	if(! $result =~ m/\d+/ ){
    		saveToFile( $out, "0,");
    	} else{ 
 		saveToFile( $out, "$result,");
	}
    }
    $currentCmd = "cat $detailPath/imapReportSubDetail-*-$currentOpco.txt 2>null | sort -u -T /opt/mio/etc | wc -l";
    $result = `$currentCmd`;
    chomp($result);

    if (! $result =~ m/\d+/ ){
    	saveToFile ($out, "0\n");
    } else {
	saveToFile ($out, "$result\n");
	$totalSum = $totalSum + $result;  
    }
  }

  # Print Total: numPerSite1, numPerSite1, ....., totalSum
  saveToFile ($out, "Total: ");
  foreach $currentSite (sort @allSites) {
	$currentCmd = "cat $detailPath/imapReportSubDetail-$currentSite-*.txt  2>null | wc -l";
  	$result = `$currentCmd`;
	chomp($result);
  	if(! $result =~ m/\d+/ ){
  		saveToFile( $out, ",0");
  	} else{
    		saveToFile( $out, ",$result");
  	}
  }
  saveToFile ($out, ",$totalSum\n"); 
}

##############################################################################
# Report the counters one by one
# Example of input
#  Date start = 20100908,Date end = 20100917
#  Counters report,opco = opco2,site = SA2B1,Period = 201009
#  NumberOfDepositCalls = 7,NumberOfOutdialNotif = 0,NumberOfReturnCalls = 0,NumberOfSecondsDepositCalls = 7,NumberOfSecondsOutdialNotif = 0,NumberOfSecondsRetrievalCalls = 547,NumberOfSecondsReturnCalls = 0,NumberOfSlamdowns = 0,
#  Date start = ,Date end =
#   Counters report,opco = opco1,site = SA2B0,Period = 201009
#   NumberOfDepositCalls = 0,NumberOfOutdialNotif = 0,NumberOfReturnCalls = 0,NumberOfSecondsDepositCalls = 0,NumberOfSecondsOutdialNotif = 0,NumberOfSecondsRetrievalCalls = 0,NumberOfSecondsReturnCalls = 0,NumberOfSlamdowns = 0,
#  Date start = ,Date end =
#   Counters report,opco = opco8,site = SA2B7,Period = 201009
#   NumberOfDepositCalls = 0,NumberOfOutdialNotif = 0,NumberOfReturnCalls = 0,NumberOfSecondsDepositCalls = 0,NumberOfSecondsOutdialNotif = 0,NumberOfSecondsRetrievalCalls = 0,NumberOfSecondsReturnCalls = 0,NumberOfSlamdowns = 0,
sub reportCounters {
   my ( $out, $inputfilename ) = @_;
   my ( $currentsite, $currentopco );
   my @content = readFileContent($inputfilename);
   my @temp;
   my %opcositecounter = ();    # <opco|site|counter><nb>
   my %counterlist     = ();    # <counter><.>

   my $minStartDate = 0;
   my $maxStartDate = 0;
   my $minEndDate   = 0;
   my $maxEndDate   = 0;
   my ( $tag, $value );
   foreach my $line (@content) {
    $line =~ s/\s+//g;
    if (DEBUG) {
     print "$line \n";
    }
    if ( $line =~ m/Date/ ) {
     @temp = split( ",", $line );
     ( $tag, $value ) = split( "=", $temp[0] );
     if ( $value ne "" and length($value) == 8 and $value =~ m/^\d+$/ ) {
      $minStartDate = $value if ( $value < $minStartDate or $minStartDate == 0 );
      $maxStartDate = $value if ( $value > $maxStartDate or $maxStartDate == 0 );
     }
     ( $tag, $value ) = split( "=", $temp[1] );
     if ( $value ne "" and length($value) == 8 and $value =~ m/^\d+$/ ) {
      $minEndDate = $value if ( $value < $minEndDate or $minEndDate == 0 );
      $maxEndDate = $value if ( $value > $maxEndDate or $maxEndDate == 0 );
     }
    }
    elsif ( $line =~ m/Countersreport/ ) {

     # Counters report,opco = opco1,site = SA2B0,Period = 201009
     @temp = split( ",", $line );
     ( $tag, $currentopco ) = split( "=", $temp[1] );
     $abs_opcolist{$currentopco} = ".";
     ( $tag, $currentsite ) = split( "=", $temp[2] );
     $abs_sitelist{$currentsite} = ".";
    }
    else {

     # NumberOfDepositCalls = 0,NumberOfOutdialNotif = 0,NumberOfReturnCalls = 0,NumberOfSecondsDepositCalls
     @temp = split( ",", $line );
     foreach my $counter (@temp) {
      ( $tag, $value ) = split( "=", $counter );
      $counterlist{$tag} = ".";
      my $key = "${currentopco}-${currentsite}-${tag}";
      if ( exists( $opcositecounter{$key} ) ) {
       $opcositecounter{$key} += $value;
      }
      else {
       $opcositecounter{$key} = $value;
      }
     }
    }
   }
   if (DEBUG) {
    foreach my $item ( sort keys %opcositecounter ) {
     print "$item = $opcositecounter{$item}\n";
    }
   }

   saveToFile( $out, "Reporting Counters date range\n", "Start date:,", getDateToPrint($minStartDate) . "\n" );
   saveToFile( $out, "End date:,", getDateToPrint($maxEndDate) . "\n" );
#   if ( !isDateRangeComplete( $minStartDate, $maxEndDate ) ) {
#    saveToFile( $out, "Warning,Some of the dates are missing in the data collection of counters.\n" );
#   }
   saveToFile( $out, "\n" );

   # Create multiple hash in format per counter:
   # %siteopco -> <site|opco><nb>  The totals per site and opco
   # %sitelist -> <site><nb>       The totals per site
   # %opcolist -> <opco><nb>       The totals per opco 
   foreach my $countername ( sort keys %counterlist ) {

    # Init of the common variables
    %siteopco = ();
    %opcolist = ();
    %sitelist = ();
    foreach my $opcositecounteritem ( sort keys %opcositecounter ) {
     if ( $opcositecounteritem =~ m/$countername/ ) {
      @temp = split( '-', $opcositecounteritem );
      my ( $asite, $anopco ) = ( $temp[1], $temp[0] );
      $tag = $asite . "|" . $anopco;
      my $nb = $opcositecounter{$opcositecounteritem};

      # Convert seconds to minutes if duration counter
      if ( ( $opcositecounteritem =~ m/seconds/ ) or ( $opcositecounteritem =~ m/Seconds/ ) ) {
       my $minutes = ( ( $nb + 30 ) / 60 );
       $nb = int($minutes);
      }
      if ( exists( $siteopco{$tag} ) ) {
       $siteopco{$tag} += $nb;
      }
      else {
       $siteopco{$tag} = $nb;
      }
      if ( exists( $sitelist{$asite} ) ) {
       $sitelist{$asite} += $nb;
      }
      else {
       $sitelist{$asite} = $nb;
      }
      if ( exists( $opcolist{$anopco} ) ) {
       $opcolist{$anopco} += $nb;
      }
      else {
       $opcolist{$anopco} = $nb;
      }
     }
    }
    genericTableDataOutput( $out, "$counterNames{$countername}\n", 1 );
   }
}

##############################################################################
# Returns 1 if the date covers from the 1 to {28|30|31} of the month
sub isDateRangeComplete {
   my ( $minStartDate, $maxEndDate ) = @_;
   return 0 if ( 1 != substr( $minStartDate, 6, 2 ) );
   my $month = substr( $maxEndDate, 4, 2 );
   my $day   = substr( $maxEndDate, 6, 2 );
   return 1 if ( ( $month == 2 ) and ( $day >= 28 ) );
   return 1 if ( ( 1 == ( $month % 2 ) ) and ( $month < 8 ) and ( $day == 31 ) );
   return 1 if ( ( 0 == ( $month % 2 ) ) and ( $month > 7 ) and ( $day == 31 ) );
   return 1 if ( ( 0 == ( $month % 2 ) ) and ( $month < 7 ) and ( $day == 30 ) );
   return 1 if ( ( 1 == ( $month % 2 ) ) and ( $month > 7 ) and ( $day == 30 ) );
   return 0;
}

##############################################################################
# Output a table formatted based on the inputs
# formatted by the caller.
# Using global variables formatted by the caller
# %siteopco -> <site|opco><nb>
# %sitelist -> <site><nb>
# %opcolist -> <opco><nb>
sub genericTableDataOutput {
   my ( $out, $title, $opcototal ) = @_;

   # Prepare the table header
   saveToFile( $out, $title, "opco\\site," );

   # Prepare the horizontal Site list
   foreach my $site ( sort @allSites ) {
    saveToFile( $out, "$site," );
   }
   if($opcototal == 1){
    saveToFile( $out, "Total:\n" );
   } else {
    saveToFile( $out, "\n" );
   }

   # Now output the results opco/site with total at the end of each line
   foreach my $opco ( sort @opcoList ) {
    saveToFile( $out, "$opco," );
    foreach my $site (sort @allSites) {
     my $key = "${site}|${opco}";
     if ( exists( $siteopco{$key} ) ) {
      saveToFile( $out, "$siteopco{$key}," );
     }
     else {
      saveToFile( $out, "0," );
     }
    }
    if($opcototal == 1){
     my $value = $opcolist{$opco};
     if(! $value =~ m/\d+/ ){
      $value = 0;
     }
     saveToFile( $out, "${value}\n" );
    } else {
     saveToFile( $out, "\n" );
    }
   }

   # Finally output the site totals
   my $bigTotal = 0;
   saveToFile( $out, "Total: ," );
   foreach my $site (sort @allSites) {
    my $value = 0;
    if(exists($sitelist{$site})){
     saveToFile( $out, "$sitelist{$site}," );
     $value = $sitelist{$site};
    } else {
     saveToFile( $out, "0," );
    }
    $bigTotal += $value;
   }
   if($opcototal == 1){
    saveToFile( $out, "$bigTotal\n\n" );
   } else {
    saveToFile( $out, "\n\n" );
   }
}

__END__
