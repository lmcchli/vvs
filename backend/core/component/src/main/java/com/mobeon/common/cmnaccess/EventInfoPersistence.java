/**
 * 
 */
package com.mobeon.common.cmnaccess;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Calendar;

import com.abcxyz.messaging.common.util.DesignLogger;
import com.abcxyz.messaging.mfs.exception.MsgStoreException;
import com.abcxyz.messaging.scheduler.handling.AppliEventInfo;

/**
 * This class is in charge to persist a type of Event ID generated by the scheduler
 * and for which we want to keep trace in case of a cancel event is needed.
 * 
 * The list of type is maintain in an ENUM class. As example the enum 'TIMEOUT' is one of them.
 * 
 * The first application and reason for this class is to track that an event of type timeout
 * is present for the subscriber as soon as a new message has been notified.
 *  
 * @author lmcmmaz
 *
 */
public class EventInfoPersistence {
    
    /**
     * Event types enumerator 
     */
    public enum EventInfoTypes {
    	VVMTimeout,		// Timeout while waiting for a Subscriber IMAP activity 
    	VVMSMSTimeout	// Waiting for the answer to a SMS type 0, as a ping to the phone
    }; 
    
    /**
     * Type of event to persist. From the EventInfoTypes enum
     */
    private EventInfoTypes type;
    
    /**
     * Life duration of a persisted event. Default is 5 minutes
     * The goal is to make sure we don't keep an info that has never been cleaned-up
     */
    private long lifeTime = 1000*60*5;
    
    private final static String SEPARATOR = "<>";
    
    
    /**
     * @param type - enum 
     * @param liftetime - validity duration in milliseconds
     */
    public EventInfoPersistence(EventInfoTypes type, long liftetime){
        logThis("<<Create>> : type=" + type.toString() + "   lifetime=" + liftetime + " milliseconds");
        this.type = type;
        this.lifeTime = liftetime;
    }
    
    /**
     * Create a file, overwritting it if already exist. Create the path eventually if not already created.
     * @param event - The event information
     * @param msid  - The susbcriber identity
     */
    public void save(AppliEventInfo event, String msid) throws MsgStoreException{
        logThis("save() : type=" + type.toString() + "   msid=" + msid);
        
        // Build the string to be stored.
        String fileText = Long.toString(System.currentTimeMillis() + lifeTime) + SEPARATOR + event.getEventId();

        // Check the path exist
        if(!privateFolderExist(msid)){
            createPrivateFolder(msid);
        }
        
        // Create a new file and save the data
        if(fileExist(msid)){
            delete(msid);
        }
        File file = new File(getFilePath(msid));
        try {
            file.createNewFile();
            FileWriter fw = new FileWriter(file);
            fw.write(fileText);
            fw.flush();
            fw.close();
            logThis("save() : fileText=" + fileText + " - path=" + getFilePath(msid));
        } catch (IOException e) {
            logThis("save() : [ERROR] - EventInfoPersistence.create - Exception thrown " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Delete a file
     * @param msid  - The susbcriber identity
     */
    public void delete(String msid) throws MsgStoreException{
        logThis("delete() : msid=" + msid);
        if(!fileExist(msid)){
            logThis("delete() : No file found to be deleted.");
            return;
        }
        File file = new File(getFilePath(msid));
        file.delete();
        logThis("delete() : File deleted.");
    }
    
    /**
     * This method is in charge to check if the file is still valid in terms of timestamp
     * @param msid  - The susbcriber identity
     * @return true if yes. False in all other case, including the file does not exist.
     */
    public boolean isPersistentFileValid(String msid) throws MsgStoreException{
        logThis("isPersistentFileValid() : msid=" + msid);
        // Not valild if not even created
        if(!fileExist(msid)){
            logThis("isPersistentFileValid() : No file found, returning false");
            return false;
        }
        // Open the file and read the last entry
        boolean result = true;
        String fileName = getFilePath(msid);
        String eventId = getLastRecordFromFile(fileName);
        
        //In case the file is empty
        if(eventId == null){
            return false;
        }
        
        String[] fields = eventId.split(SEPARATOR);
        
        long timeoutTime = 0;
        
        if (fields[0] != null && fields[0].length() > 0) {
            try {
                timeoutTime = Long.parseLong(fields[0]);
            } catch (NumberFormatException e) {
                // Do nothing
            }
        }
         
        if(System.currentTimeMillis() > timeoutTime){
            logThis("isPersistentFileValid() : File lifetime has expired, returning false");
            result = false;
        }
        logThis("isPersistentFileValid() : File lifetime still OK, returning true");
        return result;
    }

    /**
     * This method returns the first event found in the file
     * @param msid  - The susbcriber identity
     * @return The event found. Return null otherwise
     */
    public String getEvent(String msid) throws MsgStoreException{
        logThis("getEvent() : msid=" + msid);
        // Not valid if not even created
        if(!isPersistentFileValid(msid)){
            logThis("getEvent() : No file event found");
            return null;
        }
        // Open the file and read the last entry
        String fileName = getFilePath(msid);
        String eventId = getLastRecordFromFile(fileName);
        String[] fields = eventId.split(SEPARATOR);
        logThis("getEvent() : event found: " + fields[1]);
        return fields[1];
    }
    
    /**
     * Returns true if the private folder exist
     */
    private boolean privateFolderExist(String msid){
        // Create the private folder if not already exist
        CommonMessagingAccess mfsAccess = CommonMessagingAccess.getInstance();
        String path = mfsAccess.getMoipPrivateFolder(msid, true);
        File file = new File(path);
        return file.exists();
    }
    
    /**
     * Create the private folder
     */
    private void createPrivateFolder(String msid) throws MsgStoreException {
        CommonMessagingAccess mfsAccess = CommonMessagingAccess.getInstance();
        mfsAccess.createMoipPrivateFolder(msid);
        String path = mfsAccess.getMoipPrivateFolder(msid, true);
        File file = new File(path);
        if(!file.exists()){
            file.mkdirs();
        }
    }
    
    /**
     * Return the full path to the MOIP private folder
     */
    private String getPrivateFolderPath(String msid) throws MsgStoreException{
        CommonMessagingAccess mfsAccess = CommonMessagingAccess.getInstance();
        mfsAccess.createMoipPrivateFolder(msid);
        return mfsAccess.getMoipPrivateFolder(msid, true);
    }

    /**
     * Check if a file of type 'type' already exist
     */
    private boolean fileExist(String msid) throws MsgStoreException{
        if(!privateFolderExist(msid)){
            return false;
        }
        String fileName = getPrivateFolderPath(msid) + "/" + type.toString().toLowerCase();
        File file = new File(fileName);
        return file.exists();
    }
    
    /**
     * Get the full path to the file event of type 'type'
     */
    private String getFilePath(String msid) throws MsgStoreException{
        return getPrivateFolderPath(msid) + "/" + type.toString().toLowerCase();
    }
    
    /**
     * Returns the last record of the file in case multipe exist, 'state file' for future.
     */
    private String getLastRecordFromFile(String filename){
        File file = new File(filename);
        if(!file.exists()){
            return null;
        }
        FileReader fr = null;
        String result = null;
        try {
            fr = new FileReader(file);
            BufferedReader br = new BufferedReader(fr); 
            String s; 
            while((s = br.readLine()) != null) { 
                result = s;
            } 
        } catch (FileNotFoundException e) {
            result = null;
        } catch (IOException e) {
            result = null;
        } finally {
            if (fr != null)
                try {
                    fr.close();
                } catch (IOException e) {}
        }
        return result;
    }
    
    /**
     * Local logger method.
     * @param message - The message to be logged. The name of the class is added at the begining.
     */
    private void logThis(String message){
        DesignLogger.println(Calendar.getInstance().getTime().toString() + " - EventInfoPersistence - " + message);
    }
}
