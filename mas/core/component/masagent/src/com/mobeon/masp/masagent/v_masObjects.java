/*
 *
 * Copyright (C) 1992-2009 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 252.227-7013;
 *  subparagraphs (c)(4) and (d) of the Commercial Computer
 *  Software-Restricted Rights Clause, FAR 52.227-19; and in similar
 *  clauses in the NASA FAR Supplement and other corresponding
 *  governmental regulations.
 *
 */

/*
 *                PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 */


/*
 * Arguments used to create this file:
 * -java -o mas -agent -traps 
 */


/*
 * This file is automatically generated by the MIB compiler.
 * Do Not Edit!
 */

package com.mobeon.masp.masagent;

/* --- Imports for the Java language --- */
import java.lang.*;

/* --- Imports for common SNMP objects --- */
import com.snmp.common.*;

/* --- Imports for SNMP agent specific objects --- */
import com.snmp.agent.lib.*;


/**
 * The v_masObjects family
 */
public abstract class v_masObjects extends MethodRoutine {

    /*
     * Constants for nominator values
     */
    public static final int I_masName = 0;
    public static final int I_masVersion = 1;
    public static final int I_masOperationalState = 2;
    public static final int I_masAdministrativeState = 3;
    public static final int I_masInstallDate = 4;
    public static final int I_masCurrentUpTime = 5;
    public static final int I_masAccumulatedUpTime = 6;
    public static final int I_masConfigurationState = 7;
    public static final int I_masLastConfigurationUpdateTime = 8;
    public static final int I_masLastConfigurationUpdateTicks = 9;

    /*
     * Constants for enumerations
     */
    public static final int D_masOperationalState_enabled = 1;
    public static final int D_masOperationalState_disabled = 2;

    public static final int D_masAdministrativeState_unlocked = 1;
    public static final int D_masAdministrativeState_locked = 2;
    public static final int D_masAdministrativeState_shutdown = 3;

    public static final int D_masConfigurationState_load = 1;
    public static final int D_masConfigurationState_ok = 2;
    public static final int D_masConfigurationState_nok = 3;
    public static final int D_masConfigurationState_failed = 4;


    /*
     * Initialization block executed for every constructor
     */
{
    /* The name of the family */
    this.familyName = "masObjects";

    /* number of elements in this family */
    this.elements = 10;

    /* SNMP info for members of this family */
    this.descriptors = new String[this.elements];
    this.snmpTypes =   new int[this.elements];
    this.mibObjects =  new ObjectSyntax[this.elements];
    this.valid =       new boolean[this.elements];

    this.descriptors[I_masName] = "masName";
    this.snmpTypes[I_masName] = SRSNMP.OCTET_PRIM_TYPE;
    this.mibObjects[I_masName] = new OctetString();
    this.valid[I_masName] = false;

    this.descriptors[I_masVersion] = "masVersion";
    this.snmpTypes[I_masVersion] = SRSNMP.OCTET_PRIM_TYPE;
    this.mibObjects[I_masVersion] = new OctetString();
    this.valid[I_masVersion] = false;

    this.descriptors[I_masOperationalState] = "masOperationalState";
    this.snmpTypes[I_masOperationalState] = SRSNMP.INTEGER_TYPE;
    this.mibObjects[I_masOperationalState] = new Integer32();
    this.valid[I_masOperationalState] = false;

    this.descriptors[I_masAdministrativeState] = "masAdministrativeState";
    this.snmpTypes[I_masAdministrativeState] = SRSNMP.INTEGER_TYPE;
    this.mibObjects[I_masAdministrativeState] = new Integer32();
    this.valid[I_masAdministrativeState] = false;

    this.descriptors[I_masInstallDate] = "masInstallDate";
    this.snmpTypes[I_masInstallDate] = SRSNMP.OCTET_PRIM_TYPE;
    this.mibObjects[I_masInstallDate] = new OctetString();
    this.valid[I_masInstallDate] = false;

    this.descriptors[I_masCurrentUpTime] = "masCurrentUpTime";
    this.snmpTypes[I_masCurrentUpTime] = SRSNMP.TIME_TICKS_TYPE;
    this.mibObjects[I_masCurrentUpTime] = new TimeTicks();
    this.valid[I_masCurrentUpTime] = false;

    this.descriptors[I_masAccumulatedUpTime] = "masAccumulatedUpTime";
    this.snmpTypes[I_masAccumulatedUpTime] = SRSNMP.TIME_TICKS_TYPE;
    this.mibObjects[I_masAccumulatedUpTime] = new TimeTicks();
    this.valid[I_masAccumulatedUpTime] = false;

    this.descriptors[I_masConfigurationState] = "masConfigurationState";
    this.snmpTypes[I_masConfigurationState] = SRSNMP.INTEGER_TYPE;
    this.mibObjects[I_masConfigurationState] = new Integer32();
    this.valid[I_masConfigurationState] = false;

    this.descriptors[I_masLastConfigurationUpdateTime] = "masLastConfigurationUpdateTime";
    this.snmpTypes[I_masLastConfigurationUpdateTime] = SRSNMP.OCTET_PRIM_TYPE;
    this.mibObjects[I_masLastConfigurationUpdateTime] = new OctetString();
    this.valid[I_masLastConfigurationUpdateTime] = false;

    this.descriptors[I_masLastConfigurationUpdateTicks] = "masLastConfigurationUpdateTicks";
    this.snmpTypes[I_masLastConfigurationUpdateTicks] = SRSNMP.TIME_TICKS_TYPE;
    this.mibObjects[I_masLastConfigurationUpdateTicks] = new TimeTicks();
    this.valid[I_masLastConfigurationUpdateTicks] = false;

}

    /* Java provides a no argument constructor by default */

    /*
     * Utility Routines
     */

    /**
     *  Returns a copy of the k_masObjects object.
     *
     *  @return a copy of this k_masObjects object.
     */
    public Object clone() {

        k_masObjects result = new k_masObjects();
        result = (k_masObjects) super.copy(result);
        return result;
    }   /* clone() */


    /**
     *  The k_get() method is called to retrieve the instrumentation
     *  values from the Java applet/application.  Specifying it as 
     *  abstract forces its implementation in a subclass.
     *
     *  @param serialNum specifies the serial number of the SNMP request.
     *
     *  @param contextInfo specifies context information.
     *
     *  @param nominator specifies which member of the MIB object family
     *         should be returned.
     *
     *  @param searchType specifies whether the search should be for
     *         an exact match of MIB object instance or the next MIB
     *         object instance.  Needed for table entry families of
     *         MIB objects, can be ignored for scalar families.
     *
     *  @param index specifies the table row indices for the get request.
     *         Passed in as null for scalar families of MIB objects.
     *
     *  @return an array of ObjectSyntax objects, one for each member
     *           of the MIB object family.
     */
    public abstract ObjectSyntax[] k_get(
        int serialNum,
        ContextInfo contextInfo,
        int nominator,
        int searchType,
        ObjectSyntax[] index);

    /*
     * System independent method routines
     */

    /**
     * v_get
     */
    public synchronized VarBind v_get(
        OID incoming,
        ObjectInfo object,
        int searchType,
        ContextInfo contextInfo,
        int serialNum) {

        int instLength;
        int nominator = -1;
        VarBind vb = null;
        ObjectSyntax[] objsArray = null;
        OID return_oid;
        OID[] inst_frag = new OID[2];

        /* Compute the number of instance SIDs */
        instLength = incoming.length() - object.getName().length();

        switch (searchType) {
            case SRSNMP.SEARCH_EXACT:
                if ((instLength == 1) &&
                   (incoming.getSID(incoming.length()-1) == 0)) {
                    nominator = object.getNominator();
                }
                break;

             case SRSNMP.SEARCH_NEXT:
                if (instLength <= 0) {
                    nominator = object.getNominator();
                }
                break;
        }

        if (nominator < 0) {
            return null;
        }


        /* Invoke the system dependent method routine */
        try {
            objsArray = this.k_get(serialNum, contextInfo, nominator,
                                   searchType, null);
        } catch (Exception e) {
            return null;
        }

        /* Verify an ObjectSyntax array was returned */
        if (objsArray == null) {
            return null;
        }
        /* Build response OID */
        inst_frag[0] = object.getName();
        inst_frag[1] = new OID("0");
        return_oid = OID.Cat(inst_frag);

        /* Build the response VarBind */
        try {
            vb = new VarBind(return_oid, objsArray[nominator]);
        } catch (Exception e) {
            return null;
        }

        return vb;
    }

    /**
     * v_ test method
     */
    public synchronized int v_test(
        OID incoming,
        ObjectInfo object,
        ObjectSyntax value,
        DoList[] doHead,
        DoList doCur,
        ContextInfo contextInfo) {

        int instLength = incoming.length() - object.getName().length();
        int nominator = object.getNominator();
        DoList dp = null;
        int found;
        int error_status = SRSNMP.NO_ERROR;
        ObjectSyntax[] objsArray;

        /*
         * Validate the object instance: 1) It must be of length 1  2) and the
         * instance must be 0.
         */
        if (instLength != 1 || incoming.getSID(incoming.length()-1) != 0) {
            return SRSNMP.NO_CREATION_ERROR; 
        }


        /*
         * Determine the element of the do-list which should contain this SET
         * request. This is decided by looking for a previous do-list element
         * for the same family.
         */
        found = 0;

        for (int i = 0; i < doHead.length; i++) {

            /* Get the family Object from the DoList */
            Object o = doHead[i].getFamilyObject();

            if (o == null) {
                continue;
            }

            ObjectSyntax[] dar = doHead[i].dataArray;
            if (dar == null) {
                continue;
            }

            if ((o instanceof v_masObjects) &&
                (dar != null)) {

                dp = doHead[i];
                found = 1;
                break;
            }
        }

        if (found == 0) {
            dp = doCur;
            try {
                objsArray = this.k_get(-1, contextInfo, -1, SRSNMP.SEARCH_EXACT, null);
            } catch (Exception e) {
                return SRSNMP.RESOURCE_UNAVAILABLE_ERROR;
            }
            dp.dataArray = new ObjectSyntax[objsArray.length];
            if (dp.dataArray == null) {
                System.out.println("Cannot allocate memory\n");
                return SRSNMP.RESOURCE_UNAVAILABLE_ERROR;
            }
            for (int i = 0; i < objsArray.length; i++) {
                dp.dataArray[i] = ObjectSyntax.newInstance(objsArray[i]);
                if (dp.dataArray[i] == null) {
                    return SRSNMP.RESOURCE_UNAVAILABLE_ERROR;
                }
            }
            
            dp.undoArray = new ObjectSyntax[objsArray.length];
            if (dp.undoArray == null) {
                System.out.println("Cannot allocate memory\n");
                return SRSNMP.RESOURCE_UNAVAILABLE_ERROR;
            }
            for (int i = 0; i < objsArray.length; i++) {
                dp.undoArray[i] = ObjectSyntax.newInstance(objsArray[i]);
                if (dp.undoArray[i] == null) {
                    return SRSNMP.RESOURCE_UNAVAILABLE_ERROR;
                }
            }

            /*
             * set these values to anything non-zero
             * so that the method will be called
             */
            dp.readyMethodAddress = "1";
            dp.setMethodAddress = "1";
            dp.cleanupMethodAddress = "1";
            dp.undoMethodAddress = "1";

            /* set to pending so that the _ready routine will be called */
            dp.setState(DoList.SR_PENDING_STATE);

        }

        if (error_status != SRSNMP.NO_ERROR) {
            return error_status;
        }

        switch (nominator) {

            case I_masAdministrativeState:

                if ((((Integer32)value).getValue() < 1) || (((Integer32)value).getValue() > 3)) {
                    return SRSNMP.WRONG_VALUE_ERROR;
                }

                break;

            case I_masConfigurationState:

                if ((((Integer32)value).getValue() < 1) || (((Integer32)value).getValue() > 4)) {
                    return SRSNMP.WRONG_VALUE_ERROR;
                }

                break;

            default:
                System.out.print("Internal error (invalid nominator");
                System.out.println("in v_masObjects_test)\n");
                return SRSNMP.GEN_ERROR;

       }        /* switch */

       dp.dataArray[nominator] = ObjectSyntax.newInstance(value);
       valid[object.getNominator()] = true;

       /* Do system dependent testing in k_masObjects_test */
       error_status = this.k_test(object, value, dp, contextInfo);

       return error_status;
    }

    /**
     *  The v_cleanup method frees any resources used during set processing.
     *
     *  @param trash specifies
     *
     *  @return the integer status resulting from the cleanup.
     */
    public synchronized int v_cleanup(DoList[] trash) {
        return SRSNMP.NO_ERROR;
    }   /* v_cleanup() */

}

