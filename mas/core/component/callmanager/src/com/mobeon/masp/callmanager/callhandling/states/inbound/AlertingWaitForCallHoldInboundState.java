package com.mobeon.masp.callmanager.callhandling.states.inbound;

import javax.sip.message.Response;

import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.callhandling.InboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.callhandling.events.DisconnectEvent;
import com.mobeon.masp.callmanager.callhandling.states.inbound.FailedInboundState.FailedSubState;
import com.mobeon.masp.callmanager.callhandling.states.inbound.ErrorInboundState.ErrorSubState;
import com.mobeon.masp.callmanager.events.ConnectedEvent;
import com.mobeon.masp.callmanager.events.DisconnectedEvent;
import com.mobeon.masp.callmanager.events.ErrorEvent;
import com.mobeon.masp.callmanager.events.FailedEvent;
import com.mobeon.masp.callmanager.sdp.SdpInternalErrorException;
import com.mobeon.masp.callmanager.sdp.SdpIntersection;
import com.mobeon.masp.callmanager.sdp.SdpNotSupportedException;
import com.mobeon.masp.callmanager.sip.events.SipRequestEvent;
import com.mobeon.masp.callmanager.sip.events.SipTimeoutEvent;
import com.mobeon.masp.callmanager.sip.header.SipWarning;
import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;

/**
 * Represents the sub state "Wait for Call Hold" of {@link AlertingInboundState}.
 * This sub state is entered when the inbound call has been accepted, 
 * an ACK has been received and the support for redirected RTP is activated.
 * <p>
 * In this state the initial INVITE has been setup completely and the call is
 * waiting for a call hold sent in a re-INVITE message.
 * <p>
 * All methods are synchronized to handle each event atomically.
 *
 * @author Malin Nyfeldt
 */
public class AlertingWaitForCallHoldInboundState extends AlertingInboundState {
    
    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public AlertingWaitForCallHoldInboundState(InboundCallInternal call) {
        super(call);
    }

    public String toString() {
        return "Alerting state (sub state WaitForCallHold)";
    }

    /**
     * Handles an administrators lock request.
     * <p>
     * A {@link FailedEvent} is generated.
     * A SIP BYE request is sent and the state is set to
     * {@link FailedLingeringByeInboundState}.
     * <p>
     * If the SIP BYE request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     */
    public synchronized void processLockRequest() {
        if (log.isDebugEnabled())
            log.debug("Lock requested in " + this + ". The call is disconnected.");

        if (log.isInfoEnabled()) log.info(
                "Due to a lock request, the call is disconnected with a " +
                        "SIP BYE request.");

        // Although the call is connected on a SIP level, it is not completely 
        // setup on the call client level. 
        // Therefore the call is considered failed rather than disconnected.
        call.setStateFailed(FailedSubState.LINGERING_BYE);

        String message = "The Service is temporarily unavailable due to " +
                         "the current administrative state: Locked.";
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, message, call.getConfig().
                getReleaseCauseMapping().getNetworkStatusCode(null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();
        
        sendByeRequest();
    }

    /**
     * This method is used when the Call Manager client disconnects the call.
     * <p>
     * A {@link FailedEvent} is generated,
     * the state is set to {@link FailedLingeringByeInboundState}
     * and a SIP BYE request is sent.
     * <p>
     * If the SIP BYE request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     *
     * @param disconnectEvent carries the information regarding the disconnect.
     */
    public synchronized void disconnect(DisconnectEvent disconnectEvent) {
        if (log.isDebugEnabled())
            log.debug("Disconnect received in " + this +
                    ". The call is disconnected.");

        if (log.isInfoEnabled()) log.info(
                "The service is disconnecting the call. Call is disconnected" +
                        " with a SIP BYE request.");

        // Although the call is connected on a SIP level, it is not completely 
        // setup on the call client level. 
        // Therefore the call is considered failed rather than disconnected.
        call.setStateFailed(FailedSubState.LINGERING_BYE);

        String message = "A disconnect is requested before the call is " +
                "considered completely connected.";
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, message, call.getConfig().
                getReleaseCauseMapping().getNetworkStatusCode(null, null)));

        // This is because EE expects one event per called method, but it
        // does not conform with the CCXML standard
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.NEAR_END, true));
        
        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        sendByeRequest();
    }

    /**
     * Handles a SIP ACK request.
     * <p>
     * The {@link CallTimerTask.Type.NO_ACK}
     * timer is canceled and the ACK is otherwise ignored.
     * @param sipRequestEvent carries the SIP ACK request.
     */
    public synchronized void processAck(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP ACK request was received in " + this + ".");

        call.cancelNoAckTimer();

        if (log.isInfoEnabled())
            log.info("SIP ACK request is received and ignored.");
    }

    /**
     * Handles a SIP BYE request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "OK" is sent as response to the BYE request.
     * <p>
     * If the response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param sipRequestEvent carries the SIP BYE request.
     */
    public void processBye(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP BYE request received in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "The far end has disconnected the call with a SIP BYE request.");

        // Although the call is connected on a SIP level, it is not completely 
        // setup on the call client level. 
        // Therefore the call is considered failed rather than disconnected.
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                CallDirection.INBOUND, "Call disconnected early by far end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null,
                        sipRequestEvent.getSipMessage().getQ850CauseLocation())));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send OK response for BYE request
        call.sendOkResponse(sipRequestEvent, true);
    }

    /**
     * Handles a SIP CANCEL request.
     * <p>
     * A CANCEL in this state means that no cancellation is performed since a
     * final response already has been sent for the initial INVITE request.
     * A SIP "OK" is sent as response to the CANCEL request.
     * The state is left unchanged.
     * <p>
     * If the response could not be sent, the state
     * is set to {@link ErrorInboundState} and an {@link ErrorEvent}
     * is generated.
     *
     * @param sipRequestEvent carries the SIP CANCEL request.
     */
    public void processCancel(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP CANCEL request was received in " + this + ". " +
                    "No cancellation is performed since a final response " +
                    "already has been sent for the initial INVITE request.");

        if (log.isInfoEnabled()) log.info(
                "A SIP CANCEL is received when a final response has been sent " +
                        "for the INVITE. No cancellation is performed.");

        call.sendOkResponse(sipRequestEvent, false);
    }
        
    /**
     * Handles a SIP re-INVITE request.
     * <p>
     * The re-INVITE is rejected with a SIP 488 "Not Acceptable Here" response
     * in the following situations: 
     * <ul>
     * <li>The re-INVITE contained no SDP offer.</li>
     * <li>The SDP could not be parsed due to error in SDP.</li>
     * <li>No SDP intersection could be found between the SDP offer and the 
     * local media requirements.</li>
     * <li>The re-INVITE is not a call hold request, i.e. one or several 
     * connections are NOT set to 0.0.0.0.</li>
     * </ul>
     * <p> 
     * If the SDP answer could not be created, the re-INVITE is rejected with a
     * SIP 500 response, an {@link ErrorEvent} is generated, the state is 
     * set to {@link ErrorLinberingByeInboundState}, the streams are deleted
     * and a SIP BYE request is sent.
     * <p>
     * If the response to the re-INVITE could not be sent, an
     * {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorCompletedInboundState}.
     * <p>
     * If the re-INVITE contains an acceptable call hold, a SIP "OK" response 
     * is sent for the re-INVITE and the state is set to 
     * {@link AlertingWaitForNewMediaInboundState}.
     *
     * @param sipRequestEvent carries the SIP re-INVITE request.
     */
    public synchronized void processReInvite(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP re-INVITE request received in " + this + ".");

        if (call.containsSdp(sipRequestEvent)) {
            if (log.isDebugEnabled())
                log.debug("A new remote SDP offer is received.");

            try {
                call.parseRemoteSdp(sipRequestEvent.getSipMessage());                

                if (call.isPendingSdpACallHold()) {

                    SdpIntersection sdpIntersection = call.findSdpIntersection(
                            call.getOutboundCallMediaTypes(), true);

                    // If no SDP intersection was found, reject the invite
                    if (sdpIntersection == null) {
                        if (log.isInfoEnabled()) log.info(
                                "SIP re-INVITE did not contain an acceptable SDP and is " +
                        "rejected with a SIP 488 \"Not Acceptable Here\" response.");

                        // Send NotAcceptableHere response
                        call.sendNotAcceptableHereResponse(
                                sipRequestEvent, SipWarning.RENEGOTIATION_NOT_SUPPORTED);
                    } else {
                        String sdpAnswer = call.createSdpAnswer(
                                sdpIntersection, call.getInboundConnectionProperties());

                        if (log.isDebugEnabled()) log.debug(
                                "SDP answer is included in Ok response for re-INVITE: " +
                                sdpAnswer);

                        if (log.isInfoEnabled()) log.info(
                        "SIP re-INVITE is accepted with a SIP 200 \"OK\" response.");

                        // Send a SIP "Ok" response to re-INVITE
                        sendOkResponse(sipRequestEvent, sdpAnswer);

                        call.startNoAckTimer();
                        
                        call.setStateAlerting(AlertingSubState.WAIT_FOR_NEW_MEDIA);
                    }                
                } else {
                    if (log.isInfoEnabled()) log.info(
                            "SIP re-INVITE was not a call hold as expected and is " +
                    "rejected with a SIP 488 \"Not Acceptable Here\" response.");

                    // Send NotAcceptableHere response
                    call.sendNotAcceptableHereResponse(
                            sipRequestEvent, SipWarning.RENEGOTIATION_NOT_SUPPORTED);
                }

            } catch (SdpNotSupportedException e) {
                // SDP offer could not be parsed
                String message =
                    "Could not parse remote SDP: " + e.getMessage() +
                    ". A SIP 488 \"Not Acceptable Here\" response will be sent.";
                if (log.isInfoEnabled()) log.info(message);

                // Send NotAcceptableHere response
                call.sendNotAcceptableHereResponse(sipRequestEvent, e.getSipWarning());

            } catch (SdpInternalErrorException e) {
                if (log.isDebugEnabled())
                    log.debug("Could not create SDP answer.", e);

                if (log.isInfoEnabled()) log.info(
                        "Could not create SDP answer: " + e.getMessage() +
                        ". A SIP 500 response will be sent.");

                // Send Server Internal Error response
                call.sendErrorResponse(Response.SERVER_INTERNAL_ERROR,
                        sipRequestEvent, "Could not create SDP answer.");
            
                if (log.isInfoEnabled()) log.info(
                        "Call is disconnected with a SIP BYE request.");

                call.setStateError(ErrorSubState.LINGERING_BYE);

                call.fireEvent(new ErrorEvent(
                        call, CallDirection.INBOUND,
                        "Internal error when creating response to re-INVITE. The call will " +
                                "be ended with a SIP BYE request.", false));

                // Make sure the streams are deleted after the event is sent.
                // This is done to make sure that the event is generated before any
                // event generated by stream.
                call.deleteStreams();

                sendByeRequest();
            }

        } else {
            if (log.isInfoEnabled()) log.info(
                    "SIP re-INVITE contained no new SDP and is rejected with a SIP " +
            "488 \"Not Acceptable Here\" response.");

            // Send NotAcceptableHere response
            call.sendNotAcceptableHereResponse(
                    sipRequestEvent, SipWarning.RENEGOTIATION_NOT_SUPPORTED);
        }         
    }
        
    /**
     * Handles a SIP timeout event.
     * <p/>
     * A BYE request is sent and the state is set to
     * {@link ErrorInboundState.ErrorSubState.LINGERING_BYE}.
     *
     * @param sipTimeoutEvent carries information regarding the timeout event.
     */
    public synchronized void processSipTimeout(SipTimeoutEvent sipTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP timeout expired in " + this + ".");

        call.setStateError(ErrorInboundState.ErrorSubState.LINGERING_BYE);
        call.fireEvent(new ErrorEvent(
                call, CallDirection.INBOUND,
                "SIP timeout occurred. The call will be ended with a " +
                "SIP BYE request.", false));
        call.deleteStreams();
        sendByeRequest();
    }
    

    /**
     * Handles a Call timeout.
     * <p/>
     * If the call timeout is of type {@link CallTimerTask.Type.NO_ACK}, an
     * {@link ErrorEvent} is generated, the state is set to
     * {@link ErrorLingeringByeInboundState} and a SIP BYE request is sent.
     * Otherwise, if the call timeout is of type 
     * {@link CallTimerTask.Type.REDIRECTED_RTP}, an outbound media stream is
     * created, the state is set to {@link ConnectedInboundState} and a 
     * {@link ConnectedEvent} is generated.
     */
    public void handleCallTimeout(CallTimeoutEvent callTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("A call timeout <" + callTimeoutEvent.getType() +
                    "> was received in " + this + ".");

        if (callTimeoutEvent.getType() == CallTimerTask.Type.NO_ACK) {
            String message = "The inbound call has timed out while waiting " +
                    "for an ACK. The call will be ended " +
                    "with a SIP BYE request.";

            if (log.isInfoEnabled()) log.info(message + " CalledParty: " +
                    call.getCalledParty().toString()
                    + " dialogId=" + call.getInitialDialogId());

            call.setStateError(ErrorInboundState.ErrorSubState.LINGERING_BYE);
            call.fireEvent(new ErrorEvent(
                    call, CallDirection.INBOUND, message, false));
            call.deleteStreams();
            sendByeRequest();
        
        } else if (callTimeoutEvent.getType() == CallTimerTask.Type.REDIRECTED_RTP) {
            String message = "The inbound call has timed out while waiting " +
            "for a re-INVITE with call hold. The call will be connected " +
            "without any new media being re-negotiated.";
            
            if (log.isInfoEnabled()) log.info(message + " CalledParty: " +
                    call.getCalledParty().toString()
                    + " dialogId=" + call.getInitialDialogId());

            createOutboundStream(call.getSdpIntersection());
            call.setStateConnected();
            call.fireEvent(new ConnectedEvent(call));

        } else {
            if (log.isDebugEnabled())
                log.debug("The call timeout <" + callTimeoutEvent.getType() +
                        "> is ignored.");
        }
   }

}
