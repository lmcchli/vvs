/*
 * Copyright (c) 2005 Mobeon AB. All Rights Reserved.
 */
package com.mobeon.masp.callmanager.callhandling.states.inbound;

import com.mobeon.masp.callmanager.callhandling.states.inbound.DisconnectedInboundState.DisconnectedSubState;
import com.mobeon.masp.callmanager.callhandling.InboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.CallToCall;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.releasecausemapping.Q850CauseLocationPair;
import com.mobeon.masp.callmanager.sip.message.SipRequest;
import com.mobeon.masp.callmanager.sip.message.SipRequestFactory;
import com.mobeon.masp.callmanager.events.DisconnectedEvent;
import com.mobeon.masp.callmanager.events.FailedEvent;
import com.mobeon.masp.callmanager.sip.events.SipRequestEvent;
import com.mobeon.masp.callmanager.sip.events.SipResponseEvent;
import com.mobeon.masp.callmanager.sip.events.SipTimeoutEvent;
import com.mobeon.masp.callmanager.sip.header.SipWarning;
import com.mobeon.masp.callmanager.events.ErrorEvent;
import com.mobeon.masp.callmanager.callhandling.events.DisconnectEvent;
import com.mobeon.masp.callmanager.callhandling.events.PlayEvent;
import com.mobeon.masp.callmanager.callhandling.events.RecordEvent;
import com.mobeon.masp.callmanager.callhandling.events.StopPlayEvent;
import com.mobeon.masp.callmanager.callhandling.events.StopRecordEvent;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.CMUtils;
import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.videofastupdate.MediaControlImpl;
import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;
import com.mobeon.masp.stream.IOutboundMediaStream;
import com.mobeon.masp.stream.IInboundMediaStream;

import javax.sip.message.Request;
import javax.sip.message.Response;

/**
 * Represents the inbound state Connected.
 * <p>
 * The Connected state is entered when the initial call setup INVITE has been
 * accepted by the Call Manager client and it has been acknowledged by the caller.
 * In Connected state, the Call Manager client can only disconnect the call.
 * <p>
 * All methods are synchronized to handle each event atomically.
 *
 * @author Malin Flodin
 */
public class ConnectedInboundState extends InboundCallState {

    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public ConnectedInboundState(InboundCallInternal call) {
        super(call);
    }

    public String toString() {
        return "Connected state";
    }

    /**
     * Handles an administrators lock request.
     * <p>
     * A {@link DisconnectedEvent} is generated.
     * A SIP BYE request is sent and the state is set to
     * {@link DisconnectedLingeringByeInboundState}.
     * <p>
     * If the SIP BYE request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     */
    public synchronized void processLockRequest() {
        if (log.isDebugEnabled())
            log.debug("Lock requested in " + this + ". The call is disconnected.");

        if (log.isInfoEnabled()) log.info(
                "Due to a lock request, the call is disconnected with a " +
                        "SIP BYE request.");

        // Set the state to disconnected before a disconnected event is sent
        // This is done to make sure that clean up such as stream delete has
        // been performed before the event is fired.
        call.setStateDisconnected(DisconnectedSubState.LINGERING_BYE);
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.NEAR_END, false));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        sendByeRequest();
    }

    /**
     * Handles a request to play media.
     * The media is played on the outbound stream of the call using
     * {@link InboundCallInternal#playOnOutboundStream(PlayEvent)}.
     * @param playEvent carries information regarding the play request.
     */
    public synchronized void play(PlayEvent playEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to play media was received in " + this + ".");
        call.logPlayTime();
        call.playOnOutboundStream(playEvent);
    }

    /**
     * Handles a request to record media.
     * Media is recorded from the inbound stream of the call using
     * {@link InboundCallInternal#recordOnInboundStream(RecordEvent)}.
     * @param recordEvent carries information regarding the record request.
     */
    public synchronized void record(RecordEvent recordEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to record media was received in " + this + ".");
        call.recordOnInboundStream(recordEvent);
    }

    /**
     * Handles a request to stop an ogoing play.
     * The ongoing play (if any) is stopped using
     * {@link InboundCallInternal#stopOngoingPlay(StopPlayEvent)}.
     * @param stopPlayEvent
     */
    public synchronized void stopPlay(StopPlayEvent stopPlayEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to stop an ongoing play was received in " +
                    this + ".");
        call.stopOngoingPlay(stopPlayEvent);
    }

    /**
     * Handles a request to stop an ongoing recording.
     * The ongoing recording (if any) is stopped using
     * {@link InboundCallInternal#stopOngoingRecord(StopRecordEvent)}.
     * @param stopRecordEvent
     */
    public synchronized void stopRecord(StopRecordEvent stopRecordEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to stop an ongoing record was received in " +
                    this + ".");
        call.stopOngoingRecord(stopRecordEvent);
    }

    /**
     * Handles a request to send a Video Fast Update request.
     * The Video Fast Update request is sent using the SIP INFO method.
     * <p>
     * A SIP INFO request is sent including a Picture Fast Update request.
     * If the SIP INFO request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     */
    public synchronized void processVideoFastUpdateRequest() {

        IOutboundMediaStream os = call.getOutboundStream();
        if (os.usesRTCPPictureFastUpdate()) {
            if (log.isDebugEnabled())
                log.debug("Request to send a Video Fast Update request over RTCP " +
                          "received in " + this + ".");

            IInboundMediaStream is = call.getInboundStream();
            int ssrc = is.getSenderSSRC();
            if (log.isDebugEnabled())
                log.debug("Inbound stream sender SSRC = " + ssrc);

            os.sendPictureFastUpdate(ssrc);
        }
        else {
            if (log.isDebugEnabled())
                log.debug("Request to send a Video Fast Update request over SIP INFO " +
                          "received in " + this + ".");

            if (log.isInfoEnabled()) log.info(
                    "Request to send a Video Fast Update is received. " +
                            "A SIP INFO request will be sent.");
            try {
                SipRequest sipRequest = CMUtils.getInstance().getSipRequestFactory().
                        createInfoRequest(
                                call.getDialog(),
                                SipRequestFactory.InfoType.VIDEO_FAST_UPDATE,
                                MediaControlImpl.getInstance().
                                        createPictureFastUpdateRequest(),
                                call.getPChargingVector());
                CMUtils.getInstance().getSipMessageSender().sendRequestWithinDialog(
                        call.getDialog(), sipRequest);

            } catch (Exception e) {
                call.errorOccurred(
                        "Could not send SIP INFO request: " + e.getMessage(), false);
            }
        }
    }

    /**
     * This method is used when the Call Manager client disconnects the call.
     * <p>
     * A {@link DisconnectedEvent} is generated,
     * the state is set to {@link DisconnectedLingeringByeInboundState}
     * and a SIP BYE request is sent.
     * <p>
     * If the SIP BYE request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     *
     * @param disconnectEvent carries the information regarding the disconnect.
     */
    public synchronized void disconnect(DisconnectEvent disconnectEvent) {
        if (log.isDebugEnabled())
            log.debug("Disconnect received in " + this +
                    ". The call is disconnected.");

        if (log.isInfoEnabled()) log.info(
                "The service is disconnecting the call. Call is disconnected" +
                        " with a SIP BYE request.");

        // Set the state to disconnected before a disconnected event is sent
        // This is done to make sure that clean up such as stream delete has
        // been performed before the event is fired.
        call.setStateDisconnected(DisconnectedSubState.LINGERING_BYE);
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.NEAR_END, false));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        sendByeRequest();
    }

    /**
     * Handles a SIP ACK request.
     * <p>
     * The
     * {@link com.mobeon.masp.callmanager.callhandling.CallTimerTask.Type.NO_ACK}
     * timer is canceled and the ACK is otherwise ignored.
     * @param sipRequestEvent carries the SIP ACK request.
     */
    public synchronized void processAck(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP ACK request was received in " + this + ".");

        call.cancelNoAckTimer();

        if (log.isInfoEnabled())
            log.info("SIP ACK request is received and ignored.");
    }

    /**
     * Handles a SIP BYE request.
     * <p>
     * A {@link DisconnectedEvent} is generated and the state is set to
     * {@link DisconnectedCompletedInboundState}.
     * A SIP OK response is sent for the BYE request.
     * <p>
     * If the SIP OK response could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     * @param sipRequestEvent carries the SIP BYE request.
     */
    public synchronized void processBye(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP BYE request received in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "The far end has disconnected the call with a SIP BYE request.");


        // Set the state to disconnected before a disconnected event is sent
        // This is done to make sure that clean up such as stream delete has
        // been performed before the event is fired.
        call.setStateDisconnected(DisconnectedSubState.COMPLETED);

        //check FAX detected  Q850 cause 23 :Redirection to new destination
        Q850CauseLocationPair q850pair = sipRequestEvent.getSipMessage().getQ850CauseLocation();
        if(q850pair!=null)
        {
        	int q850cause = q850pair.getCause();
        	log.debug("SIP BYE with Q850 cause: "+q850cause);
        	if(q850cause==23)
        	{
            	log.debug("SIP BYE Cause redirected (FAX)");
            	//Use Failed event in this case to drop any recorded voice mail
                call.fireEvent(new FailedEvent(
                        call, FailedEvent.Reason.REJECTED_BY_NEAR_END,CallDirection.INBOUND, "Fax detected",23));
        	}
        	else
        	{
                call.fireEvent(new DisconnectedEvent(
                        call, DisconnectedEvent.Reason.FAR_END, false));
        	}

        }
        else
        {
        	log.debug("SIP BYE with no Q850 cause");
            call.fireEvent(new DisconnectedEvent(
                    call, DisconnectedEvent.Reason.FAR_END, false));
        }


        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        call.sendOkResponse(sipRequestEvent, true);
    }


    /**
     * Handles a SIP CANCEL request.
     * <p>
     * A CANCEL in this state means that no cancellation is performed since a
     * final response already has been sent for the INVITE request.
     * A SIP "OK" is sent as response to the CANCEL request.
     * The state is left unchanged.
     * <p>
     * If the response could not be sent, an {@link ErrorEvent} is generated and
     * the state is set to {@link ErrorInboundState}.
     *
     * @param sipRequestEvent carries the SIP CANCEL request.
     */
    public synchronized void processCancel(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP CANCEL request was received in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "A SIP CANCEL is received when a final response has been sent " +
                        "for the INVITE. No cancellation is performed.");

        call.sendOkResponse(sipRequestEvent, false);
    }

    /**
     * Handles a SIP re-INVITE request.
     * <p>
     * Only re-negotiations where the remote SDP is identical to the previously
     * received remote SDP is allowed.
     * <p>
     * If the PRACK request contains a new SDP offer, the offer is parsed and
     * examined using
     * {@link #retrieveAndStoreRemoteSdpAfterConnect(SipRequestEvent)}.
     * <p>
     * If the re-negotiation is acceptable, a SIP "OK" response is sent for the
     * re-INVITE.
     * <p>
     * If the re-INVITE contained no SDP offer, it is rejected with a SIP
     * 488 "Not Acceptable Here" response.
     * <p>
     * If the response to the re-INVITE could not be sent, an
     * {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param sipRequestEvent carries the SIP re-INVITE request.
     */
    public synchronized void processReInvite(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP re-INVITE request received in " + this + ".");

        try {
            if (call.containsSdp(sipRequestEvent)) {
                if (log.isDebugEnabled())
                    log.debug("A new remote SDP offer is received.");

                // Retrieve and store the remote SDP offer
                retrieveAndStoreRemoteSdpAfterConnect(sipRequestEvent);
                if (log.isDebugEnabled())
                    log.debug("Remote SDP offer is parsed and accepted.");

                String sdpAnswer = call.getLocalSdpAnswer();

                if (log.isDebugEnabled()) log.debug(
                        "SDP answer is included in Ok response for re-INVITE: " +
                                sdpAnswer);

                if (log.isInfoEnabled()) log.info(
                        "SIP re-INVITE is accepted with a SIP 200 \"OK\" response.");

                // Send a SIP "Ok" response to re-INVITE
                sendOkResponse(sipRequestEvent, sdpAnswer);

                call.startNoAckTimer();

            } else {
            	if (log.isDebugEnabled())
                    log.debug("SIP re-INVITE request does not contain SDP");

                String sdpAnswer = call.getLocalSdpAnswer();

                if (log.isDebugEnabled()) log.debug(
                        "SDP answer is included in Ok response for re-INVITE: " +
                                sdpAnswer);

                if (log.isInfoEnabled()) log.info(
                        "SIP re-INVITE without SDP is accepted with a SIP 200 \"OK\" response, CONTAINING AN SDP.");

                // Send a SIP "Ok" response to re-INVITE
                sendOkResponse(sipRequestEvent, sdpAnswer);

                call.startNoAckTimer();

            }

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled()) log.debug("Re-INVITE handling failed.");
        }
    }

    /**
     * Handles a SIP OPTIONS request.
     * <p>
     * A SIP OK response is generated. If an error
     * occurs when sending the OK response, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     * @param sipRequestEvent
     */
    public synchronized void processOptions(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP OPTIONS request received in " + this + ".");

        if (log.isInfoEnabled()) log.info("SIP OPTIONS request is answered.");

        call.sendOkResponse(sipRequestEvent, false);
    }

    /**
     * If the call is joined, SIP INFO messages are forwarded to the other call
     * in this state.
     *
     * @param sipRequestEvent
     */
    public synchronized void processInfo(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled()) {
            log.debug("SIP INFO request received in " + this + ".");
        }

        if (log.isInfoEnabled()) {
            log.info("SIP INFO request is forwarded to the Inbound Call.");
        }

        CallToCall otherCall = call.getJoinedToCall();
        if (call.isCallJoined() && (otherCall != null) &&
                call.containsMediaControl(sipRequestEvent)) {
            String tag = otherCall.forwardVFURequest(sipRequestEvent);
            if (tag != null) {
                call.addPendingRequest(tag, sipRequestEvent);
            }
        } else {
            if (log.isInfoEnabled()) {
                log.info("SIP INFO request is rejected since it is not " +
                        "supported in current state.");
            }

            call.sendMethodNotAllowedResponse(sipRequestEvent);
        }
    }

    /**
     * Parses a SIP response. In this state, only responses to INFO requests are
     * expected. If the INFO request is responded with either SIP Request Timeout
     * or SIP Call/Transaction Does Not Exist, the call is disconnected, i.e.
     * a BYE request is sent, a {@link DisconnectedEvent} is generated and the
     * state is set to {@link DisconnectedLingeringByeInboundState}.
     * Otherwise if the call is joined, the response is forwarded to the joined
     * call.
     * Otherwise, the response is handled using
     * {@link #processInfoResponse(SipResponseEvent)}.
     * @param sipResponseEvent carries the SIP response.
     */
    public synchronized void processSipResponse(SipResponseEvent sipResponseEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP " + sipResponseEvent.getResponseCode() +
                    " response received for a " + sipResponseEvent.getMethod() +
                    " request in " + this + ".");

        Integer responseCode =
                sipResponseEvent.retrieveResponseCodeForMethod(Request.INFO);

        if (responseCode != null) {
            if (log.isDebugEnabled())
                log.debug("Processing INFO response");
            if ((responseCode == Response.CALL_OR_TRANSACTION_DOES_NOT_EXIST) ||
                    (responseCode == Response.REQUEST_TIMEOUT)) {
                if (log.isInfoEnabled())
                    log.info("SIP " + responseCode + " response to an INFO request. " +
                            "The call will be disconnected with a SIP BYE request.");
                // Set the state to disconnected before a disconnected event is sent
                // This is done to make sure that clean up such as stream delete has
                // been performed before the event is fired.
                call.setStateDisconnected(DisconnectedSubState.LINGERING_BYE);
                call.fireEvent(new DisconnectedEvent(
                        call, DisconnectedEvent.Reason.NEAR_END, false));

                // Make sure the streams are deleted after the event is sent.
                // This is done to make sure that the event is generated before any
                // event generated by stream.
                call.deleteStreams();

                sendByeRequest();
            } else {
                CallToCall otherCall = call.getJoinedToCall();
                if (call.isCallJoined() && (otherCall != null)) {
                    otherCall.forwardVFUResponse(sipResponseEvent);
                } else {
                    processInfoResponse(sipResponseEvent);
                }
            }
        }
    }

    /**
     * Handles a SIP timeout event.
     * <p>
     * If a timeout occurred for an INVITE, this must be an ACK that
     * never arrived for a received re-INVITE request. A SIP BYE request
     * is sent, an {@link ErrorEvent} is generated and the state is set to
     * {@link ErrorLingeringByeInboundState}.
     * <p>
     * Otherwise, an {@link ErrorEvent} is generated and the state is set to
     * {@link ErrorInboundState}.
     * However, if the timeout occurred for a SIP INFO request, whether or not
     * to consider the call disconnected depends upon configuration. If
     * configuration indicates that the call shall not be considered
     * disconnected, the SIP timeout is simply ignored.
     *
     * @param sipTimeoutEvent carries information regarding the timeout event.
     */
    public synchronized void processSipTimeout(SipTimeoutEvent sipTimeoutEvent) {
        if (log.isDebugEnabled()) {
            log.debug("SIP timeout expired in " + this + ".");
        }

        boolean disconnectOnSipTimeout =
                call.getConfig().getDisconnectOnSipTimeout();

        // If the timeout occurred for a SIP INFO request, whether or not to
        // consider the call disconnected depends upon configuration
        if (!disconnectOnSipTimeout &&
                sipTimeoutEvent.getMethod().equals(Request.INFO)) {
            if (log.isDebugEnabled()) {
                log.debug("SIP timeout event received for INFO method. " +
                        "Will be ignored.");
            }

        // If a timeout occurred for an INVITE, this must be an ACK that
        // never arrived for a received re-INVITE request.
        } else if (sipTimeoutEvent.getMethod().equals(Request.INVITE)){
            if (log.isDebugEnabled())
                log.debug("SIP timeout event received for INVITE method. " +
                        "This is probably a re-INVITE that timed out.");

            call.setStateError(ErrorInboundState.ErrorSubState.LINGERING_BYE);
            call.fireEvent(new ErrorEvent(
                    call, CallDirection.INBOUND,
                    "SIP timeout occurred for re-INVITE. The call will " +
                            "be ended with a SIP BYE request.", false));
            call.deleteStreams();
            sendByeRequest();

        } else {
            call.errorOccurred(
                    "SIP timeout expired. The call is considered completed.",
                    false);
        }
    }

    /**
     * Handles a Call timeout.
     * <p/>
     * If the call timeout is of type {@link CallTimerTask.Type.NO_ACK}, an
     * {@link ErrorEvent} is generated, the state is set to
     * {@link ErrorLingeringByeInboundState} and a SIP BYE request is sent.
     */
    public synchronized void handleCallTimeout(CallTimeoutEvent callTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("A call timeout <" + callTimeoutEvent.getType() +
                    "> was received in " + this + ".");

        if (callTimeoutEvent.getType() == CallTimerTask.Type.NO_ACK) {
            String message = "The call has timed out while waiting " +
                    "for an ACK on a re-INVITE. The call will be ended " +
                    "with a SIP BYE request.";

            log.error(message + " CalledParty: " + call.getCalledParty().toString()
                    + " dialogId=" + call.getInitialDialogId());

            call.setStateError(ErrorInboundState.ErrorSubState.LINGERING_BYE);
            call.fireEvent(new ErrorEvent(
                    call, CallDirection.INBOUND, message, false));
            call.deleteStreams();
            sendByeRequest();
        } else {
            if (log.isDebugEnabled())
                log.debug("The call timeout <" + callTimeoutEvent.getType() +
                        "> is ignored.");
        }
    }

    /**
     * Handles the detection of an abandoned stream.
     * <p>
     * In this state this is interpreted as the call being abandoned by far end.
     * The call is disconnected, i.e. a {@link DisconnectedEvent} is generated,
     * the state is set to {@link DisconnectedLingeringByeInboundState} and a
     * SIP BYE request is sent.
     */
    public synchronized void handleAbandonedStream() {
        if (log.isDebugEnabled())
            log.debug("A stream was detected abandoned in " + this +
                      ". The call is disconnected.");

        if (log.isInfoEnabled()) log.info(
                "A stream was detected abandoned. The call is disconnected " +
                        "with a SIP BYE request.");

        // Set the state to disconnected before a disconnected event is sent
        // This is done to make sure that clean up such as stream delete has
        // been performed before the event is fired.
        call.setStateDisconnected(DisconnectedSubState.LINGERING_BYE);
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.FAR_END_ABANDONED, false));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        sendByeRequest();
    }

}

