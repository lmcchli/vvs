/*
 * Copyright (c) 2005 Mobeon AB. All Rights Reserved.
 */
package com.mobeon.masp.callmanager.callhandling.states.inbound;

import com.mobeon.masp.callmanager.events.ErrorEvent;
import com.mobeon.masp.callmanager.events.FailedEvent;
import com.mobeon.masp.callmanager.callhandling.events.AcceptEvent;
import com.mobeon.masp.callmanager.callhandling.events.RecordEvent;
import com.mobeon.masp.callmanager.callhandling.events.RejectEvent;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.callhandling.events.PlayEvent;
import com.mobeon.masp.callmanager.callhandling.events.StopPlayEvent;
import com.mobeon.masp.callmanager.callhandling.events.StopRecordEvent;
import com.mobeon.masp.callmanager.sip.events.SipRequestEvent;
import com.mobeon.masp.callmanager.sip.message.SipResponse;
import com.mobeon.masp.callmanager.callhandling.InboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.CMUtils;
import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.configuration.ReliableResponseUsage;
import com.mobeon.common.cmnaccess.oam.CommonOamManager;
import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;

import javax.sip.message.Response;
import java.util.Iterator;
import java.util.List;
import java.util.Arrays;

/**
 * Represents the sub state "Early Media" of {@link AlertingInboundState}.
 * This sub state is entered when the Call Manager client whishes to play media
 * before accepting the inbound call. This media is called early media.
 * <p>
 * This sub state is entered when the initial call setup INVITE is
 * received, a provisional Trying response has been sent as response and the
 * Call Manager client has requested to negotiate early media types which
 * caused a SIP Session Progress to be sent.
 * In this state, the Call Manager client can either play early media, record early media,
 * accept or reject the call.
 * <p>
 * This class is thread-safe.
 * All methods are synchronized to handle each event atomically.
 *
 * @author Malin Flodin
 */
public class AlertingEarlyMediaInboundState extends AlertingInboundState {

    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public AlertingEarlyMediaInboundState(InboundCallInternal call) {
        super(call);
    }

    public String toString() {
        return "Alerting state (sub state EarlyMedia)";
    }

    /**
     * Handles an administrators lock request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * The initial inbound INVITE is rejected with a SIP
     * "Temporarily Unavailable" response.
     * <p>
     * If the SIP error response could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     */
    public synchronized void processLockRequest() {
        String message = "The Service is temporarily unavailable due to " +
                         "the current administrative state: Locked.";

        if (log.isDebugEnabled())
            log.debug("Lock requested in " + this + ". " + message);

        if (log.isInfoEnabled()) log.info("Due to a lock request, the INVITE is rejected with SIP " +
                                          "503 response.");

        // Set call failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, message,
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        call.sendErrorResponse(
                Response.SERVICE_UNAVAILABLE,
                call.getInitialSipRequestEvent(), message);
    }

    /**
     * Handles a request to play media.
     * The media is played on the outbound stream of the call using
     * {@link InboundCallInternal#playOnOutboundStream(PlayEvent)}.
     * @param playEvent carries information regarding the play request.
     */
    public synchronized void play(PlayEvent playEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to play media was received in " + this + ".");
        call.logPlayTime();
        call.playOnOutboundStream(playEvent);
    }
    
    /**
     * Handles a request to record media.
     * Media is recorded from the inbound stream of the call using
     * {@link InboundCallInternal#recordOnInboundStream(RecordEvent)}.
     * @param recordEvent carries information regarding the record request.
     */
    public synchronized void record(RecordEvent recordEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to record media was received in " + this + ".");
        call.recordOnInboundStream(recordEvent);
    }

    /**
     * Handles a request to stop an ogoing play.
     * The ongoing play (if any) is stopped using
     * {@link InboundCallInternal#stopOngoingPlay(StopPlayEvent)}.
     * @param stopPlayEvent
     */
    public synchronized void stopPlay(StopPlayEvent stopPlayEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to stop an ongoing play was received in " +
                    this + ".");
        call.stopOngoingPlay(stopPlayEvent);
    }

    /**
     * Handles a request to stop an ongoing recording.
     * The ongoing recording (if any) is stopped using
     * {@link InboundCallInternal#stopOngoingRecord(StopRecordEvent)}.
     * @param stopRecordEvent
     */
    public synchronized void stopRecord(StopRecordEvent stopRecordEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to stop an ongoing record was received in " +
                    this + ".");
        call.stopOngoingRecord(stopRecordEvent);
    }

    /**
     * This method is used when the Call Manager client accepts the inbound
     * call. The streams and an SDP answer has already been created.
     * <ul>
     * <li>
     * A SIP "OK" response is sent using {@link #sendOkResponse(String)}.
     * </li>
     * <li>
     * The state is set to {@link AlertingAcceptingInboundState}.
     * </li>
     * </ul>
     *
     * @param acceptEvent carries the information regarding the accept event.
     */
    public synchronized void accept(AcceptEvent acceptEvent) {
        if (log.isDebugEnabled())
            log.debug("Accept received in " + this + ".");

        if (log.isInfoEnabled()) log.info("The service is accepting the call.");

        try {
            // Go to Alerting Accepting state before sending response
            // This is to be sure that the ACK can be received.
            call.setStateAlerting(AlertingSubState.ACCEPTING);            

            // SDP should be included in the SIP 200 OK response if the
            // SIP 183 Session Progress response was sent unreliably.
            String sdp = null;
            if (call.useReliableProvisionalResponses() == ReliableResponseUsage.NO) {
                sdp = call.getLocalSdpAnswer();
            }
            
            // Build list of proprietary headers
            List<String> extensionHeaderList = Arrays.asList(PROPRIETARY_HEADER_FOR_INITIAL_INVITE_200OK_RESPONSE);

            // Send a SIP OK response
            sendOkResponse(sdp,extensionHeaderList);

            Object perf = null;
            if (CommonOamManager.profilerAgent.isProfilerEnabled()) {
                try {
                    perf = CommonOamManager.profilerAgent.enterCheckpoint("MAS.CM.In.Sip.Req.Invite.2.Accepted");
                } finally {
                    CommonOamManager.profilerAgent.exitCheckpoint(perf);
                }
            }

            if (log.isDebugEnabled())
                log.debug("Ok response is sent for INVITE.");

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Accepting call failed.");
        }
    }

    /**
     * This method is used when the Call Manager client rejects the inbound
     * call.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "Forbidden" response is sent for the initial INVITE.
     * <p>
     * If the SIP response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param rejectEvent carries the information regarding the reject event.
     */
    public synchronized void reject(RejectEvent rejectEvent) {
        if (log.isDebugEnabled())
            log.debug("Reject received in " + this + ". " + rejectEvent.getMessage());

        if (log.isInfoEnabled())
            log.info("The service is rejecting the call. A SIP " + rejectEvent.getCode() + " response will be sent.");

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, rejectEvent.getMessage(),
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        call.sendErrorResponse(rejectEvent.getCode(), call.getInitialSipRequestEvent(), rejectEvent.getMessage());
    }

    /**
     * Handles a SIP BYE request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "Request Terminated" response is sent for the pending INVITE request.
     * A SIP "OK" is sent as response to the BYE request.
     * <p>
     * If a SIP response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param sipRequestEvent carries the SIP BYE request.
     */
    public synchronized void processBye(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP BYE request received in " + this + ".");

        if (log.isInfoEnabled()) log.info("The far end has disconnected the call with a SIP BYE request.");

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                CallDirection.INBOUND, "Call disconnected early by far end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null,
                        sipRequestEvent.getSipMessage().getQ850CauseLocation())));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Request Terminated response to initial INVITE
        call.sendErrorResponse(
                Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(),
                "Call terminated due to a BYE request.");

        // Send OK response to BYE request
        call.sendOkResponse(sipRequestEvent, true);
    }

    /**
     * Handles a SIP CANCEL request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "Request Terminated" response is sent for the pending INVITE request.
     * A SIP "OK" is sent as response to the CANCEL request.
     * <p>
     * If a SIP response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param sipRequestEvent carries the SIP CANCEL request.
     */
    public synchronized void processCancel(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP CANCEL received in " + this + ".");

        if (log.isInfoEnabled()) log.info("The far end has canceled the call with a SIP CANCEL request.");

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                CallDirection.INBOUND, "Call disconnected early by far end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null,
                        sipRequestEvent.getSipMessage().getQ850CauseLocation())));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Request Terminated response to initial INVITE
        call.sendErrorResponse(
                Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(),
                "Call terminated due to a CANCEL request.");

        // Send OK response to CANCEL request
        call.sendOkResponse(sipRequestEvent, true);
    }
    
    


    /**
     * Handles a Call timeout.
     * <p>
     * If it was the {@link CallTimerTask.Type.CALL_NOT_ACCEPTED} timer that
     * expired, a {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * <p>
     * If it was the {@link CallTimerTask.Type.SESSION_PROGRESS_RETRANSMISSION} timer that
     * expired, a SIP 183 Session Progress is sent. If the Call uses reliable provisional response,
     * the state is set to {@link AlertingEarlyMediaInboundWaitForPrackState}. Otherwise no state change occurs.
     * <p>
     * If it was the {@link CallTimerTask.Type.EXPIRES} timer that
     * expired, a {@link FailedEvent} is generated, the state is set to
     * {@link FailedCompletedInboundState} and the call is rejected with a
     * SIP 487 "Request Terminated" response.
     * <p>
     * Other timers should no expire in this state, and are ignored.
     * @param callTimeoutEvent carries information regarding the call timeout.
     */
    public synchronized void handleCallTimeout(CallTimeoutEvent callTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("A call timeout <" + callTimeoutEvent.getType() +
                    "> was received in " + this + ".");

        int nsc = call.getConfig().getReleaseCauseMapping().
                getNetworkStatusCode(null, null);

        if (callTimeoutEvent.getType() == CallTimerTask.Type.CALL_NOT_ACCEPTED) {
            String message = "The inbound call was not accepted by the service " +
                             "in time. It is considered abandoned and a SIP 408 " +
                             "response will be sent.";
            if (log.isInfoEnabled()) log.info(message);

            // Set call to failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
            call.fireEvent(new FailedEvent(
                    call, FailedEvent.Reason.NEAR_END_ABANDONED,
                    CallDirection.INBOUND, message, nsc));

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            call.sendErrorResponse(
                    Response.REQUEST_TIMEOUT, call.getInitialSipRequestEvent(),
                    "Call was not accepted in time.");

        } else if (callTimeoutEvent.getType() == CallTimerTask.Type.EXPIRES) {
            String message = "The expires timer expired for the INVITE. " +
                             "A SIP 487 response will be sent.";
            if (log.isInfoEnabled()) log.info(message);

            // Set call to failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
            call.fireEvent(new FailedEvent(
                    call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                    CallDirection.INBOUND, message, nsc));

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            call.sendErrorResponse(
                    Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(),
                    "Expires timer expired.");

        } else if (callTimeoutEvent.getType() == CallTimerTask.Type.SESSION_PROGRESS_RETRANSMISSION) {

           try {
               // Send a SIP 183 session progress response in order to prevent proxies
               // from canceling the transaction. RFC3261 section 13.3.1.1
               sendSessionProgressResponse();
            } catch (IllegalStateException e) {
                if (log.isDebugEnabled())
                    log.debug("Regular SIP 183 Session Progress response retransmission on call failed.");
            }
            
        } else {
            if (log.isDebugEnabled())
                log.debug("The call timeout <" + callTimeoutEvent.getType() +
                        "> is ignored.");
        }
    }
    
    /**
     * Handles the detection of an abandoned stream.
     * <p>
     * In this state this is interpreted as the call being abandoned by far end.
     * The call is disconnected, i.e. a {@link FailedEvent} is generated,
     * the state is set to {@link FailedCompletedInboundState} and a
     * SIP 487 response is sent.
     */
    public synchronized void handleAbandonedStream() {
        if (log.isDebugEnabled())
            log.debug("A stream was detected abandoned in " + this +
                      ". The call is disconnected.");
        
        String message = "A stream was detected abandoned. A SIP 487 response will be sent.";

        if (log.isInfoEnabled()) log.info(message);

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                CallDirection.INBOUND, message,
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        call.sendErrorResponse(
                Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(),
                "Abandoned stream detected.");
    }

    
    /**
     * Sends a SIP "Session Progress" response for the initial INVITE request
     * without an SDP Answer in order to prevent proxies from canceling the transaction.
     * <p>
     * RFC3261 section 13.3.1.1: 
     * <blockquote>
     * If the UAS desires an extended period of time to answer the INVITE,
     * it will need to ask for an "extension" in order to prevent proxies
     * from canceling the transaction.  A proxy has the option of canceling
     * a transaction when there is a gap of 3 minutes between responses in a
     * transaction.  To prevent cancellation, the UAS MUST send a non-100
     * provisional response at every minute, to handle the possibility of
     * lost provisional responses.
     * </blockquote>
     * 
     * <p>
     * If the SIP "Session Progress" response could not be sent, an error is
     * reported.
     * 
     * @throws IllegalStateException if the SIP response could not be sent.
     */
    private void sendSessionProgressResponse()
            throws IllegalStateException {

        try {
            
            if (call.useReliableProvisionalResponses() == ReliableResponseUsage.YES) {
                // The Session Progress response shall be sent reliably and the
                // call setup will be delayed until the PRACK is received.
                
                // Go to Alerting Early Media Inbound Wait-for-PRACK state
                call.setStateAlerting(AlertingSubState.EARLY_MEDIA_INBOUND_WAIT_FOR_PRACK);
                
                SipResponse sipResponse =
                        CMUtils.getInstance().getSipResponseFactory().
                                createSessionProgressResponse(
                                        call.getInitialSipRequestEvent(),
                                        null,
                                        call.getConfig().getRegisteredName(),
                                        true, true, false);
                    
                addProprietaryHeadersFromApplication(sipResponse, PROPRIETARY_HEADER_FOR_SESSION_PROGRESS_RESPONSE);
                processPEarlyMediaInInitialRequest(sipResponse, true);
                // Unlike in AlertingNewCallInboundState, don't add UPDATE as 'allow'ed in header since
                // we don't support SIP Updates during Early Media stage...
                // (i.e. do not call addUpdateMethodInAllowHeader() method...)
                
                sipMessageSender.sendReliableProvisionalResponse(
                        call.getDialog(), sipResponse);
            } else {
                // The Session Progress response is sent unreliably.
                SipResponse sipResponse =
                        CMUtils.getInstance().getSipResponseFactory().
                                createSessionProgressResponse(
                                        call.getInitialSipRequestEvent(), null,
                                        call.getConfig().getRegisteredName(),
                                        false, true, false);
                
                addProprietaryHeadersFromApplication(sipResponse, PROPRIETARY_HEADER_FOR_SESSION_PROGRESS_RESPONSE);
                processPEarlyMediaInInitialRequest(sipResponse, true);

                sipMessageSender.sendResponse(sipResponse);
            }

        } catch (Exception e) {
            String errorMessage =
                    "Could not send SIP \"Session Progress\" response: " +
                            e.getMessage();
            call.errorOccurred(errorMessage, false);
            throw(new IllegalStateException());
        }
    }
}
