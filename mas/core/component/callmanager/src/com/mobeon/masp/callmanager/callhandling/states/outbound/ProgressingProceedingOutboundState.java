/*
 * Copyright (c) 2006 Mobeon AB. All Rights Reserved.
 */
package com.mobeon.masp.callmanager.callhandling.states.outbound;

import com.mobeon.masp.callmanager.callhandling.OutboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask.Type;
import com.mobeon.masp.callmanager.callhandling.events.DisconnectEvent;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.events.*;
import com.mobeon.masp.callmanager.sip.events.SipResponseEvent;
import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.sdp.SdpIntersection;
import com.mobeon.masp.callmanager.sdp.SdpInternalErrorException;
import com.mobeon.masp.callmanager.releasecausemapping.Q850CauseLocationPair;
import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;

import javax.sip.message.Response;
import javax.sip.address.SipURI;

/**
 * A substate of the outbound state Progressing.
 * <p>
 * The Progressing Proceeding substate is entered when the initial call setup
 * INVITE is sent and a provisional response has been received from the callee.
 * <p>
 * All methods are synchronized to handle each event atomically.
 *
 * @author Malin Flodin
 */
public class ProgressingProceedingOutboundState extends ProgressingOutboundState {

    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public ProgressingProceedingOutboundState(OutboundCallInternal call) {
        super(call);
    }

    public String toString() {
        return "Progressing state (sub state Proceeding)";
    }

    /**
     * Handles an administrators lock request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedLingeringCancelOutboundState}.
     * A SIP CANCEL request is sent.
     * <p>
     * If the SIP CANCEL could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorCompletedOutboundState}.
     */
    public synchronized void processLockRequest() {
        if (log.isDebugEnabled())
            log.debug("Lock requested in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "Due to a lock request, the call is disconnected with a " +
                        "SIP CANCEL request.");

        // Set call failed
        call.setStateFailed(FailedOutboundState.FailedSubState.LINGERING_CANCEL);

        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.OUTBOUND, "Call rejected due to lock request.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Cancel request
        sendCancelRequest();
    }

    /**
     * Handles a requested disconnect.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedLingeringCancelOutboundState}.
     * A SIP CANCEL request is sent.
     * <p>
     * If the SIP CANCEL could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorCompletedOutboundState}.
     * @param disconnectEvent carries the information regarding the disconnect.
     */
    public synchronized void disconnect(DisconnectEvent disconnectEvent) {
        if (log.isDebugEnabled())
            log.debug("Disconnect received in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "The service is disconnecting the call. Call is disconnected" +
                        " with a SIP CANCEL request.");

        // Set call failed
        call.setStateFailed(FailedOutboundState.FailedSubState.LINGERING_CANCEL);

        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.OUTBOUND, "Call disconnected by near end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));

        // This is because EE expects one event per called method, but it
        // does not conform with the CCXML standard
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.NEAR_END, true));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Cancel request
        sendCancelRequest();
    }

    /**
     * Handles a Call timeout.
     * <p>
     * If it was the {@link CallTimerTask.Type.CALL_NOT_CONNECTED} or 
     * {@link CallTimerTask.Type.CALL_NOT_CONNECTED_EXTENSION} timer that
     * expired, a {@link FailedEvent} is generated, the state is set to
     * {@link FailedLingeringCancelOutboundState} and a SIP CANCEL request is
     * sent. Other timers should no expire in this state, and are ignored.
     * <br>
     * If the SIP CANCEL request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorCompletedOutboundState}.
     * @param callTimeoutEvent carries information regarding the call timeout.
     */
    public synchronized void handleCallTimeout(CallTimeoutEvent callTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("A call timeout <" + callTimeoutEvent.getType() +
                    "> was received in " + this + ".");

        Type callTimeoutEventtype = callTimeoutEvent.getType();
        if (callTimeoutEventtype == CallTimerTask.Type.CALL_NOT_CONNECTED || callTimeoutEventtype == CallTimerTask.Type.CALL_NOT_CONNECTED_EXTENSION) {

            int responseCode = Response.REQUEST_TIMEOUT;
            
            String message;
            if(callTimeoutEventtype == CallTimerTask.Type.CALL_NOT_CONNECTED) {
                message = "The \"max duration before connected\" timer has " +
                             "expired, i.e. the call was not connected in time. " +
                             "It is handled as if a SIP " + responseCode +
                             " response was received. Call is disconnected with a " +
                             "SIP CANCEL request.";
            } else {
                message = "The \"call not connected extension\" timer has " +
                        "expired, i.e. the call was not connected in time. " +
                        "It is handled as if a SIP " + responseCode +
                        " response was received. Call is disconnected with a " +
                        "SIP CANCEL request.";
            }
            if (log.isInfoEnabled()) log.info(message);

            call.setStateFailed(FailedOutboundState.FailedSubState.LINGERING_CANCEL);

            FailedEvent failedEvent = new FailedEvent(
                    call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                    CallDirection.OUTBOUND,
                    message,
                    call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        responseCode, null));
            call.fireEvent(failedEvent);

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            // Send CANCEL request
            sendCancelRequest();

        } else {
            if (log.isDebugEnabled())
                log.debug("The call timeout <" + callTimeoutEvent.getType() +
                        "> is ignored.");
        }
    }


    //===================== Private Methods =======================

    /**
     * Processes a 1xx response received for an outbound INVITE.
     * <p>
     * The response is treated as described below and the state is set to
     * {@link ProgressingProceedingOutboundState}.
     * <p>
     * <ul>
     * <li>"Trying" response:<br> Is only debug logged.
     * </li>
     * <li>"Call Is Being Forwarded" response:<br> Is only debug logged.
     * </li>
     * <li>"Queued" response:<br> Is only debug logged.
     * </li>
     * <li>"Ringing" response:<br>
     * A {@link com.mobeon.masp.callmanager.events.ProgressingEvent} is
     * generated indicating no early media.
     * </li>
     * <li>"Session Progress" response and all other 1xx responses:<br>
     * Is handled using {@link #processSessionProgressResponse(SipResponseEvent)}.
     * </li>
     * <ul>
     * <p>
     * Finally, if the response is not a 100 Trying and was sent reliably, an
     * empty SIP PRACK request is generated for the response.
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process1xxResponseToInvite(SipResponseEvent sipResponseEvent) {

        // Check if response is from a forked dialog and update call with new dialog
        handleForkedSipDialog(sipResponseEvent, false);

        int responseCode = sipResponseEvent.getResponseCode();

        try {
            if ((responseCode == Response.TRYING) ||
                    (responseCode == Response.CALL_IS_BEING_FORWARDED) ||
                    (responseCode == Response.QUEUED)) {

                // Trying, Call Is Being Forwarded and Queued is only logged.
                if (log.isInfoEnabled()) log.info(
                        "No special action is taken for the SIP " + responseCode +
                                " response.");


            } else if (responseCode == Response.RINGING) {
                if (log.isInfoEnabled()) log.info("The call is ringing.");
                call.fireEvent(new ProgressingEvent(call, false));

            } else {
                // All other SIP 1xx responses should be handled as a
                // Session Progress response
                if (log.isDebugEnabled())
                    log.debug("A session progress has been received.");

                processSessionProgressResponse(sipResponseEvent);
            }

            if ((responseCode != Response.TRYING) &&
                    (call.isProvisionalResponseReliable(sipResponseEvent))) {

                // Send PRACK request
                sendPrackRequest(sipResponseEvent);

                if (log.isInfoEnabled()) log.info(
                        "PRACK is sent to acknowledge the reliable SIP " +
                                responseCode + " response.");
            }

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Processing provisional response resulted in " +
                        "call disconnected.");
        }
    }

    /**
     * Processes a 2xx response received for an outbound INVITE.
     * <p>
     * The response is treated as described below:
     * <ul>
     * <li>
     * A SIP ACK request is sent using {@link #sendAckRequest()}.
     * </li>
     * <li>
     * The SDP Answer (if any) is retrieved, parsed and stored in the call
     * using {@link #retrieveAndStoreSdpAnswer(SipResponseEvent)}.
     * </li>
     * <li>
     * A check is made to verify that the SDP Answer was stored ok in the call
     * using {@link #assertSdpAnswerExists()}.
     * </li>
     * <li>
     * An SDP intersection between the SDP offer in the initial INVITE and the
     * SDP answer is located using {@link #retrieveSdpIntersection(int)}.
     * </li>
     * <li>
     * An outbound media stream is created using
     * {@link #createOutboundStream(int, SdpIntersection)}.
     * </li>
     * <li>
     * A {@link ConnectedEvent} is generated and the state is set to
     * {@link ConnectedOutboundState}.
     * </li>
     * </ul>
     *
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process2xxResponseToInvite(SipResponseEvent sipResponseEvent) {

        // Check if response is from a forked dialog and update call with new dialog
        handleForkedSipDialog(sipResponseEvent, false);

        if (log.isInfoEnabled()) log.info(
                "A SIP final ok response is received for INVITE. " +
                        "An ACK will be sent and media negotiation is performed.");

        try {
            // Send ACK request
            sendAckRequest();

            if (log.isDebugEnabled())
                log.debug("SIP ACK is sent.");

            // Retrieve and store the SDP answer
            retrieveAndStoreSdpAnswer(sipResponseEvent);

            if (log.isDebugEnabled())
                log.debug("SDP answer is parsed.");

            // Verify that an SDP answer was included
            assertSdpAnswerExists();

            // Retrieve the SDP intersection
            SdpIntersection sdpIntersection =
                    retrieveSdpIntersection(sipResponseEvent.getResponseCode());

            if (log.isDebugEnabled())
                log.debug("SDP answer matches outbound media types.");
                
            //handle re-negotiated SDP on Inbound Stream
            if (log.isDebugEnabled())
                log.debug("reNegotiatedSdpOnInboundStream");
            call.reNegotiatedSdpOnInboundStream(sdpIntersection);

            addFarEndConnection(sipResponseEvent);

            // Create the outbound stream.
            createOutboundStream(
                    sipResponseEvent.getResponseCode(), sdpIntersection);

            if (log.isDebugEnabled())
                log.debug("Outbound stream is created.");

            // The call is considered connected.
            call.setStateConnected();
            call.fireEvent(new ConnectedEvent(call));

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Processing 2xx response resulted in call disconnected.");
        }
        catch (SdpInternalErrorException e) {
            String message =
                    "Processing 2xx response resulted in call disconnected.";
            if (log.isDebugEnabled())
                log.debug(message, e);
        }
    }

    /**
     * Processes a 3xx response received for an outbound INVITE.
     * <p>
     * The response is treated as described below:
     * <ul>
     * <li>
     * A check is made to verify that a call redirection is allowed to be
     * handled. This is done using
     * {@link #assertCallRedirectionAllowed(SipResponseEvent)}.
     * </li>
     * <li>
     * The redirection contacts are retrieved from the response and stored in
     * the call using
     * {@link OutboundCallInternal#retrieveContacts(SipResponseEvent)}.
     * </li>
     * <li>
     * The next contact URI to try is retrieved using
     * {@link #getNextContact(SipResponseEvent)}.
     * </li>
     * <li>
     * A redirected INVITE request is sent using
     * {@link #sendRedirectedInvite(javax.sip.address.SipURI)}.
     * </li>
     * <li>
     * The state is set to {@link ProgressingCallingOutboundState}.
     * </li>
     * </ul>
     *
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process3xxResponseToInvite(SipResponseEvent sipResponseEvent) {
        try {
            // Check if response is from a forked dialog and update call with new dialog
            handleForkedSipDialog(sipResponseEvent, false);

            // Verify that call redirection is allowed.
            assertCallRedirectionAllowed(sipResponseEvent);

            if (log.isDebugEnabled())
                log.debug("First level of redirection.");

            if (log.isInfoEnabled()) log.info(
                    "The call has been redirected to another contact. " +
                            "A redirected INVITE will be sent.");

            // TODO: Phase 2! Handle expires in Contact header?

            // Retrieve contacts from the 3xx response.
            call.retrieveContacts(sipResponseEvent);

            // Get the contact URI to try this time
            SipURI contactUri = getNextContact(sipResponseEvent);

            if (log.isDebugEnabled())
                log.debug("The next URI to try: " + contactUri);

            // Sent the redirected INVITE request
            sendRedirectedInvite(contactUri);

            if (log.isDebugEnabled())
                log.debug("A redirected SIP INVITE request is sent.");

            call.setStateProgressing(ProgressingSubState.CALLING);

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Processing 3xx response resulted in call disconnected.");
        }
    }

    /**
     * Processes a 5xx response received for an outbound INVITE.
     * <p>
     * The response is treated as described below:
     * <ul>
     * <li>
     * If the INVITE has been previously redirected, the next contact URI to
     * try is retrieved using {@link #getNextContact(SipResponseEvent)} and a
     * redirected INVITE request is sent using {@link #sendRedirectedInvite(SipURI)}.
     * The state is set to {@link ProgressingCallingOutboundState}.
     * </li>
     * <li>
     * Otherwise, the call is rejected using
     * {@link #callRejected(Integer, Q850CauseLocationPair)}
     * </li>
     * </ul>
     *
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process5xxResponseToInvite(SipResponseEvent sipResponseEvent) {
        try {
            // TODO: Phase 2! Handle expires in Contact header?

            // Check if response is from a forked dialog and update call with new dialog
            handleForkedSipDialog(sipResponseEvent, false);

            if (call.isRedirected()) {
                // Get the contact URI to try this time
                SipURI contactUri = getNextContact(sipResponseEvent);
                if (log.isDebugEnabled())
                    log.debug("The next URI to try: " + contactUri);

                // Sent the redirected INVITE request
                sendRedirectedInvite(contactUri);

                if (log.isDebugEnabled())
                    log.debug("A redirected SIP INVITE request is sent.");

                if (log.isInfoEnabled()) log.info(
                        "A SIP 5xx response is received for a redirected INVITE. " +
                                "A new contact is tried and a new INVITE is sent.");

                call.setStateProgressing(ProgressingSubState.CALLING);
            } else {
                callRejected(
                        sipResponseEvent.getResponseCode(),
                        sipResponseEvent.getSipMessage().getQ850CauseLocation());
            }

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Processing 5xx response resulted in call disconnected.");
        }
    }

}
