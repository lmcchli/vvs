/*
 * Copyright (c) 2006 Mobeon AB. All Rights Reserved.
 */
package com.mobeon.masp.callmanager.callhandling.states.inbound;

import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.callhandling.InboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.callhandling.events.DisconnectEvent;
import com.mobeon.masp.callmanager.events.ErrorEvent;
import com.mobeon.masp.callmanager.events.FailedEvent;
import com.mobeon.masp.callmanager.events.DisconnectedEvent;
import com.mobeon.masp.callmanager.sip.events.SipRequestEvent;
import com.mobeon.masp.callmanager.sip.events.SipTimeoutEvent;
import com.mobeon.masp.callmanager.sip.header.SipWarning;
import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.CallManagerLicensingException;
import com.mobeon.masp.callmanager.CallProperties;
import com.mobeon.masp.callmanager.sdp.SdpIntersection;
import com.mobeon.masp.callmanager.sdp.SdpInternalErrorException;
import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;
import com.mobeon.masp.stream.ConnectionProperties;

import javax.sip.message.Response;

/**
 * Represents the inbound call state Alerting.
 * <p>
 * The Alerting state is entered when an initial call setup INVITE is
 * received. In Alerting state, the call receipient can choose to play early
 * media or to accept or decline the call.
 * <p>
 * All methods are synchronized to handle each event atomically.
 *
 * @author Malin Flodin
 */
public abstract class AlertingInboundState extends InboundCallState {

    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public enum AlertingSubState {
        NEW_CALL,
        WAIT_FOR_PRACK,
        WAIT_FOR_CALL_HOLD,
        WAIT_FOR_NEW_MEDIA,
        WAIT_FOR_NEW_MEDIA_ACK,
        EARLY_MEDIA,
        EARLY_MEDIA_WAIT_FOR_PRACK,
        EARLY_MEDIA_INBOUND_WAIT_FOR_PRACK,
        SESSION_ESTABLISHMENT_WAIT_FOR_PRACK,
        SESSION_ESTABLISHMENT,
        ACCEPTING,
        PROXYING
    }

    public AlertingInboundState(InboundCallInternal call) {
        super(call);
    }

    /**
     * This method is used when the Call Manager client disconnects the call.
     * <p>
     * Since the initial INVITE has not yet been acknowledged, a BYE request
     * cannot be sent. The INVITE request will be anwered with a 487 response.
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     *
     * @param disconnectEvent carries the information regarding the disconnect.
     */
    public synchronized void disconnect(DisconnectEvent disconnectEvent) {
        if (log.isDebugEnabled()) {
            log.debug("Disconnect is requested while in " + this +
                    ", the INVITE will be answered with a 487 response.");
        }

        if (log.isInfoEnabled()) {
            log.info("The service is disconnecting the call.");
        }

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        String message = "A disconnect is requested before the call is connected.";
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, message,
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));

        // This is because EE expects one event per called method, but it does not conform with the CCXML standard
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.NEAR_END, true));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send a 487 response to the INVITE request
        call.sendErrorResponse(Response.REQUEST_TERMINATED,
                call.getInitialSipRequestEvent(), message);
    }

    /**
     * Handles a SIP re-INVITE request.
     * A SIP re-INVITE in this state means that an INVITE has been
     * received while the initial INVITE request is pending.
     * <p>
     * The re-INVITE is rejected with a SIP "Request Pending" response.
     * The state is left unchanged.
     * <p>
     * If the response could not be sent, the state is set to
     * {@link ErrorInboundState} and an {@link ErrorEvent} is generated.
     * @param sipRequestEvent carries the SIP re-INVITE request.
     */
    public synchronized void processReInvite(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP Re-INVITE received in " + this + ".");

        if (log.isInfoEnabled()) log.info("SIP re-INVITE request is rejected with a SIP 491 response");

        call.sendErrorResponse(Response.REQUEST_PENDING, sipRequestEvent,
                "Re-negotiation is not supported.");
    }

    /**
     * Handles a SIP OPTIONS request.
     * <p>
     * A SIP OK response is generated. If an error
     * occurs when sending the OK response, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     * @param sipRequestEvent
     */
    public synchronized void processOptions(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP OPTIONS request received in " + this + ".");

        if (log.isInfoEnabled()) log.info("SIP OPTIONS request is answered.");

        call.sendOkResponse(sipRequestEvent, false);
    }

    /**
     * Handles a SIP timeout event.
     * <p>
     * An {@link ErrorEvent} is generated and the state is set to
     * {@link ErrorInboundState}.
     * @param sipTimeoutEvent carries information regarding the timeout event.
     */
    public synchronized void processSipTimeout(SipTimeoutEvent sipTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP timeout expired in " + this + ".");
        call.errorOccurred(
                "SIP timeout expired. The call is considered completed.",
                false);
    }


    //========================= Helper methods ===========================

    /**
     * Creates an inbound media stream and returns the connection properties for
     * the new stream.
     * <p>
     * If the stream could not be created an {@link ErrorEvent} is generated,
     * the state is set to {@link ErrorInboundState} and a SIP "Server Internal
     * Error" response is sent.
     * @throws IllegalStateException if the stream could not be created.
     */
    protected ConnectionProperties createInboundStream()
            throws IllegalStateException {

        ConnectionProperties inboundConnectionProperties;
        try {
            // In this case (offer created locally) we do not have
            // an SDP intersection so we pass null instead.
            inboundConnectionProperties = call.createInboundStream(null);
        } catch(CallManagerLicensingException e) {

            if (log.isInfoEnabled()) log.info(e.getMessage());

            // Set call failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);

            call.fireEvent(new FailedEvent(
                    call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                    CallDirection.INBOUND, "Could not create streams: " + e.getMessage() +
                    ". A SIP 503 response will be sent.",
                    call.getConfig().getReleaseCauseMapping().getNoLicenseNetworkStatusCode()));


            call.sendErrorResponse(
                    Response.SERVICE_UNAVAILABLE,
                    call.getInitialSipRequestEvent(),
                    e.getMessage());

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            throw(new IllegalStateException(e.getMessage()));

        } catch (Exception e) {
            String errorMessage =
                    "Could not create inbound stream: " + e.getMessage() +
                            ". A SIP 500 response will be sent.";

            log.info("Could not create streams: "+e.getMessage(),e);

            call.errorOccurred(errorMessage, false);

            // Send Server Internal Error response
            call.sendErrorResponse(
                    Response.SERVER_INTERNAL_ERROR,
                    call.getInitialSipRequestEvent(),
                    errorMessage);

            throw(new IllegalStateException());
        }
        return inboundConnectionProperties;
    }

    /**
     * Creates media streams based on the SDP intersection. The inbound streams
     * connection properties are returned so that they can be used in the SDP
     * answer.
     * <p>
     * If the streams could not be created, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     * A SIP "Server Internal Error" response is sent.
     * If the SIP error response (one of those listed above) could not be sent,
     * the error is logged.
     *
     * @param sdpIntersection
     * @throws IllegalStateException if the streams could not be created.
     */
    protected ConnectionProperties createStreams(SdpIntersection sdpIntersection)
            throws IllegalStateException {
        ConnectionProperties inboundConnectionProperties;
        try {
            inboundConnectionProperties = call.createInboundStream(sdpIntersection);
            call.createOutboundStream(sdpIntersection);
        } catch(CallManagerLicensingException e) {

            if (log.isInfoEnabled()) log.info(e.getMessage());

            // Set call failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);

            call.fireEvent(new FailedEvent(
                    call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                    CallDirection.INBOUND, "Could not create streams: " + e.getMessage() +
                    ". A SIP 503 response will be sent.",
                    call.getConfig().getReleaseCauseMapping().getNoLicenseNetworkStatusCode()));


            call.sendErrorResponse(
                    Response.SERVICE_UNAVAILABLE,
                    call.getInitialSipRequestEvent(),
                    e.getMessage());

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();


            throw(new IllegalStateException(e.getMessage()));

        } catch (Exception e) {
            call.errorOccurred(
                    "Could not create streams: " + e.getMessage() +
                            ". A SIP 500 response will be sent.", false);

            log.info("Could not create streams: "+e.getMessage(),e);


            // Send Server Internal Error response
            call.sendErrorResponse(
                    Response.SERVER_INTERNAL_ERROR,
                    call.getInitialSipRequestEvent(),
                    "Could not create media streams.");

            throw(new IllegalStateException());
        }

        return inboundConnectionProperties;
    }

    /**
     * Creates an outbound stream based on an SDP intersection.
     * <p>
     * If the stream could not be created, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorCompletedInboundState}.
     * A SIP "Server Internal Error" response is sent.
     * If the SIP error response could not be sent, the error is logged.
     *
     * @param sdpIntersection
     * @throws IllegalStateException if the stream could not be created.
     */
    protected void createOutboundStream(SdpIntersection sdpIntersection)
            throws IllegalStateException {
        // Create the outbound stream. If error at creation,
        // disconnect the call
        try {
            call.createOutboundStream(sdpIntersection);
        } catch (Exception e) {
            call.errorOccurred(
                    "Could not create outbound stream: " + e.getMessage() +
                            ". A SIP 500 response will be sent.", false);

            log.info("Could not create streams: "+e.getMessage(),e);


            // Send Server Internal Error response
            call.sendErrorResponse(
                    Response.SERVER_INTERNAL_ERROR,
                    call.getInitialSipRequestEvent(),
                    "Could not create media streams.");

            throw(new IllegalStateException());
        }
    }

    /**
     * Sets up media streams and creates an SDP answer.
     * <p>
     * First, an SDP intersection is retrieved using
     * {@link #retrieveSdpIntersection()}.
     * Then media streams are created. If <code>createOutboundStream</code>
     * is set to false, only an inbound media stream is created.
     * Finally, an SDP answer is created using
     * {@link #createSdpAnswerFromIntersection(SdpIntersection, ConnectionProperties)}.
     *
     * @param createOutboundStream
     *          Indicates whether an outbound media stream should be created
     *
     * @return Returns an SDP answer.
     */
    protected String setupMediaAndCreateSdpAnswer(boolean createOutboundStream) {
        //Create streams
        setupMedia(createOutboundStream);

        // Create the SDP answer.
        String localSdp = createSdpAnswerFromIntersection(
                call.getSdpIntersection(), call.getInboundConnectionProperties());

        if (log.isDebugEnabled())
            log.debug("SDP answer is created.");

        return localSdp;
    }

    /**
     * @param createOutboundStream
     */
        // Retrieve the SDP intersection
    protected void setupMedia(boolean createOutboundStream) {
        SdpIntersection sdpIntersection = retrieveSdpIntersection();

        if (log.isDebugEnabled())
            log.debug("SDP intersection found.");

        // Create the streams.
        try {
            call.createInboundStream(sdpIntersection);
            if (createOutboundStream)
                call.createOutboundStream(sdpIntersection);
        } catch(CallManagerLicensingException e) {

            if (log.isInfoEnabled()) log.info(e.getMessage());

            // Set call failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);

            call.fireEvent(new FailedEvent(
                    call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                    CallDirection.INBOUND, "Could not create streams: " + e.getMessage() +
                    ". A SIP 503 response will be sent.",
                    call.getConfig().getReleaseCauseMapping().getNoLicenseNetworkStatusCode()));


            call.sendErrorResponse(
                    Response.SERVICE_UNAVAILABLE,
                    call.getInitialSipRequestEvent(),
                    e.getMessage());

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();


            throw(new IllegalStateException(e.getMessage()));
       } catch (Exception e) {
           log.info("Could not create streams: "+e.getMessage(),e);
            call.errorOccurred(
                    "Could not create streams: " + e.getMessage() +
                            ". A SIP 500 response will be sent.", false);

            // Send Server Internal Error response
            call.sendErrorResponse(
                    Response.SERVER_INTERNAL_ERROR,
                    call.getInitialSipRequestEvent(),
                    "Could not create media streams.");

            throw(new IllegalStateException(e.getMessage()));
        }


        if (log.isDebugEnabled())
            log.debug("Streams are created.");
    }

    /**
     * Sets up media streams and creates an SDP offer.
     * <p>
     * First, an inbound stream is created using {@link #createInboundStream()}.
     * Then an SDP offer is created using
     * {@link #createSdpOfferFromConnectionProperties(ConnectionProperties)}.
     *
     * @return Returns an SDP offer.
     */
    protected String setupMediaAndCreateSdpOffer() {
        // If the call type is not known, i.e. could not be found in
        // the inbound INVITE, the default call type to use when
        // constructing SDP offer is retrieved from configuration.
        if (call.getCallType() == CallProperties.CallType.UNKNOWN) {
            call.retrieveCallTypeFromConfiguration();
        }

        // Create the inbound stream.
        ConnectionProperties inboundConnectionProperties =
                createInboundStream();

        if (log.isDebugEnabled())
            log.debug("Inbound stream is created.");

        // Create an SDP offer.
        String localSdp =
                createSdpOfferFromConnectionProperties(inboundConnectionProperties);

        if (log.isDebugEnabled())
            log.debug("SDP offer is created.");
        return localSdp;
    }

    /**
     * Tries to find a match between the offered SDP (included in the
     * initial INVITE) and the calls outbound call media types.
     * <p>
     * If no media match was found, a {@link FailedEvent} is generated and the
     * state is set to {@link FailedCompletedInboundState}.
     * A SIP "Not Acceptable Here" response is sent.
     * If the SIP error response could not be sent,
     * an {@link ErrorEvent} is generated and the state is set to
     * {@link ErrorInboundState}.
     *
     * @throws IllegalStateException if an SDP intersection could not be found.
     */
    protected SdpIntersection retrieveSdpIntersection() {


        SdpIntersection sdpIntersection =null;
        try
        {
            sdpIntersection=call.findSdpIntersection(call.getOutboundCallMediaTypes(), false);
        }
        catch (SdpInternalErrorException e)
        {
            log.error("retrieveSdpIntersection unable to find Intercsection",e);
        }
        // If no SDP intersection was found, reject the invite
        if (sdpIntersection == null) {
            String message =
                    "Media negotiation failed. A SIP 488 response will be sent.";
            if (log.isInfoEnabled()) log.info(message);

            // Set call failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
            call.fireEvent(new FailedEvent(
                    call, FailedEvent.Reason.MEDIA_NEGOTIATION_FAILED,
                    CallDirection.INBOUND, message,
                    call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));


            // Send "Not Acceptable Here" response
            call.sendNotAcceptableHereResponse(
                    call.getInitialSipRequestEvent(),
                    SipWarning.INCOMPATIBLE_MEDIA_FORMAT);

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();


            throw(new IllegalStateException(message));
        }

        return sdpIntersection;
    }

    /**
     * Close the call following the 
     * @param errorCode error code used in the SIP response  
     * @param additionalInfo present depending of the error code
     * @param sipRequestEvent sipRequest to based the response on (INVITE, PRACK or UPDATE)
     */
    public synchronized void handleError(int errorCode, String additionalInfo, SipRequestEvent sipRequestEvent) {
        String message = "Call not accepted.  Error " + errorCode + " - " + additionalInfo;

        if (log.isInfoEnabled())
            log.info(message);

        int nsc = call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(null, null);

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);

        call.fireEvent(new FailedEvent(call, FailedEvent.Reason.NEAR_END_ABANDONED, CallDirection.INBOUND, message, nsc));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any event generated by stream.
        call.deleteStreams();

        call.sendErrorResponse(errorCode, sipRequestEvent, additionalInfo);
    }

    //========================= Private methods ===========================

    /**
     * Creates and returns an SDP Answer based on an SDP intersection and the
     * connection properties for the inbound media stream.
     * <p>
     * If the SDP answer could not be created an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     * A SIP "Server Internal Error" response is sent.
     * If the SIP error response could not be sent,
     * an {@link ErrorEvent} is generated and the state is set to
     * {@link ErrorInboundState}.
     *
     * @param sdpIntersection
     * @param inboundConnectionProperties
     * Connection properties of the inbound media stream
     * @return the SDP Answer.
     * @throws IllegalStateException if the SIP response could not be sent.
     */
    protected String createSdpAnswerFromIntersection(
            SdpIntersection sdpIntersection,
            ConnectionProperties inboundConnectionProperties)
            throws IllegalStateException {

        String sdpAnswer;
        try {
            sdpAnswer = call.createSdpAnswer(
                    sdpIntersection, inboundConnectionProperties);
        } catch (SdpInternalErrorException e) {
            if (log.isDebugEnabled())
                log.debug("Could not create SDP answer.", e);

            call.errorOccurred(
                    "Could not create SDP answer: " + e.getMessage() +
                    ". A SIP 500 response will be sent.", false);

            // Send Server Internal Error response
            call.sendErrorResponse(
                    Response.SERVER_INTERNAL_ERROR,
                    call.getInitialSipRequestEvent(),
                    "Could not create SDP answer.");

            throw(new IllegalStateException());
        }

        return sdpAnswer;
    }

    /**
     * Creates an SDP offer based on the connection properties for the inbound
     * media stream.
     * <p>
     * If the SDP offer could not be created an {@link ErrorEvent} is generated,
     * the state is set to {@link ErrorInboundState} and a SIP "Server Internal
     * Error" response is sent.
     * @param inboundConnectionProperties Properties for the inbound media stream.
     * @return the created SDP offer.
     * @throws IllegalStateException if the SDP offer could not be created.
     */
    private String createSdpOfferFromConnectionProperties(
            ConnectionProperties inboundConnectionProperties)
            throws IllegalStateException {

        String sdpOffer;
        try {
            sdpOffer = call.createSdpOffer(inboundConnectionProperties);
        } catch (SdpInternalErrorException e) {
            String errorMessage = "Could not create SDP offer: " + e.getMessage() +
                    ". A SIP 500 response will be sent.";
            call.errorOccurred(errorMessage, false);

            // Send Server Internal Error response
            call.sendErrorResponse(
                    Response.SERVER_INTERNAL_ERROR,
                    call.getInitialSipRequestEvent(),
                    errorMessage);

            throw(new IllegalStateException());
        }
        return sdpOffer;
    }

}
