/*
 * Copyright (c) 2006 Mobeon AB. All Rights Reserved.
 */
package com.mobeon.masp.callmanager.callhandling.states.outbound;

import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask.Type;
import com.mobeon.masp.callmanager.callhandling.OutboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.callhandling.CallToCall;
import com.mobeon.masp.callmanager.callhandling.events.DisconnectEvent;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.callhandling.events.RecordEvent;
import com.mobeon.masp.callmanager.callhandling.events.StopRecordEvent;
import com.mobeon.masp.callmanager.events.*;
import com.mobeon.masp.callmanager.sdp.SdpInternalErrorException;
import com.mobeon.masp.callmanager.sdp.SdpIntersection;
import com.mobeon.masp.callmanager.sip.events.SipResponseEvent;
import com.mobeon.masp.callmanager.sip.events.SipRequestEvent;
import com.mobeon.masp.callmanager.sip.message.SipRequest;
import com.mobeon.masp.callmanager.sip.message.SipRequestFactory;
import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.CMUtils;
import com.mobeon.masp.callmanager.videofastupdate.MediaControlImpl;
import com.mobeon.masp.callmanager.releasecausemapping.Q850CauseLocationPair;
import com.mobeon.masp.stream.IOutboundMediaStream;
import com.mobeon.masp.stream.IInboundMediaStream;

import javax.sip.message.Response;
import javax.sip.message.Request;

/**
 * A substate of the outbound state Progressing.
 * <p>
 * The Progressing Early Media substate is entered when the initial call setup
 * INVITE is sent and a session progress response has been received from the
 * callee. In this state it is possible to record early media from the inbound
 * stream.
 * <p>
 * All methods are synchronized to handle each event atomically.
 *
 * @author Malin Flodin
 */
public class ProgressingEarlyMediaOutboundState extends ProgressingOutboundState {

    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public ProgressingEarlyMediaOutboundState(OutboundCallInternal call) {
        super(call);
    }

    public String toString() {
        return "Progressing state (sub state EarlyMedia)";
    }

    /**
     * Handles an administrators lock request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedLingeringCancelOutboundState}.
     * A SIP CANCEL request is sent.
     * <p>
     * If the SIP CANCEL could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorCompletedOutboundState}.
     */
    public synchronized void processLockRequest() {
        if (log.isDebugEnabled())
            log.debug("Lock requested in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "Due to a lock request, the call is disconnected with a " +
                        "SIP CANCEL request.");

        // Set call failed
        call.setStateFailed(FailedOutboundState.FailedSubState.LINGERING_CANCEL);

        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.OUTBOUND, "Call rejected due to lock request.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Cancel request
        sendCancelRequest();
    }

    /**
     * Handles a request to record media.
     * Media is recorded from the inbound stream of the call using
     * {@link OutboundCallInternal#recordOnInboundStream(RecordEvent)}.
     * @param recordEvent carries information regarding the record request.
     */
    public synchronized void record(RecordEvent recordEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to record media was received in " + this + ".");
        call.recordOnInboundStream(recordEvent);
    }

    /**
     * Handles a request to stop an ongoing recording.
     * The ongoing recording (if any) is stopped using
     * {@link OutboundCallInternal#stopOngoingRecord(StopRecordEvent)}.
     * @param stopRecordEvent
     */
    public synchronized void stopRecord(StopRecordEvent stopRecordEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to stop an ongoing record was received in " +
                this + ".");
        call.stopOngoingRecord(stopRecordEvent);
    }

    /**
     * Handles a request to send a Video Fast Update request.
     * The Video Fast Update request is sent using the SIP INFO method.
     * <p>
     * A SIP INFO request is sent including a Picture Fast Update request.
     * If the SIP INFO request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorCompletedOutboundState}.
     */
    public synchronized void processVideoFastUpdateRequest() {
        IOutboundMediaStream os = call.getOutboundStream();
        if (os.usesRTCPPictureFastUpdate()) {
            if (log.isDebugEnabled())
                log.debug("Request to send a Video Fast Update request over RTCP " +
                          "received in " + this + ".");

            IInboundMediaStream is = call.getInboundStream();
            int ssrc = is.getSenderSSRC();
            if (log.isDebugEnabled())
                log.debug("Inbound stream sender SSRC = " + ssrc);

            os.sendPictureFastUpdate(ssrc);
        }
        else {
            if (log.isDebugEnabled())
                log.debug("Request to send a Video Fast Update request over SIP INFO " +
                          "received in " + this + ".");

            if (log.isInfoEnabled()) log.info(
                    "Request to send a Video Fast Update is received. " +
                            "A SIP INFO request will be sent.");

            try {
                SipRequest sipRequest =
                        CMUtils.getInstance().getSipRequestFactory().
                                createInfoRequest(
                                        call.getDialog(),
                                        SipRequestFactory.InfoType.VIDEO_FAST_UPDATE,
                                        MediaControlImpl.getInstance().
                                                createPictureFastUpdateRequest(),
                                        call.getPChargingVector());
                CMUtils.getInstance().getSipMessageSender().sendRequestWithinDialog(
                        call.getDialog(), sipRequest);

            } catch (Exception e) {
                call.errorOccurred(
                        "Could not send SIP INFO request: " + e.getMessage(), false);
            }
        }
    }

    /**
     * Handles a requested disconnect.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedLingeringCancelOutboundState}.
     * A SIP CANCEL request is sent.
     * <p>
     * If the SIP CANCEL could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorCompletedOutboundState}.
     * @param disconnectEvent carries the information regarding the disconnect.
     */
    public synchronized void disconnect(DisconnectEvent disconnectEvent) {
        if (log.isDebugEnabled())
            log.debug("Disconnect received in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "The service is disconnecting the call. Call is disconnected" +
                        " with a SIP CANCEL request.");

        // Set call failed
        call.setStateFailed(FailedOutboundState.FailedSubState.LINGERING_CANCEL);

        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.OUTBOUND, "Call disconnected by near end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));

        // This is because EE expects one event per called method, but it does
        // not conform with the CCXML standard
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.NEAR_END, true));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Cancel request
        sendCancelRequest();
    }

    /**
     * If the call is joined, SIP INFO messages are forwarded to the other call
     * in this state.
     *
     * @param sipRequestEvent
     */
    public synchronized void processInfo(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled()) {
            log.debug("SIP INFO request received in " + this + ".");
        }

        if (log.isInfoEnabled()) {
            log.info("SIP INFO request is forwarded to the Inbound Call.");
        }

        CallToCall otherCall = call.getJoinedToCall();
        if (call.isCallJoined() && (otherCall != null) &&
                call.containsMediaControl(sipRequestEvent)) {
            String tag = otherCall.forwardVFURequest(sipRequestEvent);
            if (tag != null) {
                call.addPendingRequest(tag, sipRequestEvent);
            }
        } else {
            if (log.isInfoEnabled()) {
                log.info("SIP INFO request is rejected since it is not " +
                        "supported in current state.");
            }

            call.sendMethodNotAllowedResponse(sipRequestEvent);
        }
    }

    /**
     * First processes the response as described in
     * {@link super#processSipResponse(SipResponseEvent)}.
     * <p>
     * Then checks if the response is a SIP INFO response.
     * If an INFO request has been responded with either SIP Request Timeout
     * or SIP Call/Transaction Does Not Exist, the call is canceled, i.e.
     * a CANCEL request is sent, a {@link FailedEvent} is generated and the
     * state is set to {@link FailedLingeringCancelOutboundState}.
     * Otherwise if the call is joined, the response is forwarded to the joined
     * call.
     * Otherwise, the response is handled using
     * {@link #processInfoResponse(SipResponseEvent)}.
     *
     * Handles a SIP response.
     * <p>
     * <ul>
     * <li>
     * A provisional response is handled using
     * {@link #process1xxResponseToInvite(SipResponseEvent)}
     * </li>
     * <li>
     * A 2xx response is handled using
     * {@link #process2xxResponseToInvite(SipResponseEvent)}
     * </li>
     * <li>
     * A 3xx response is handled using
     * {@link #process3xxResponseToInvite(SipResponseEvent)}
     * </li>
     * <li>
     * A 5xx response is handled using
     * {@link #process5xxResponseToInvite(SipResponseEvent)}
     * </li>
     * <li>
     * All other responses are rejected using
     * {@link #callRejected(Integer, Q850CauseLocationPair)}
     * </li>
     * </ul>
     * @param sipResponseEvent carries the SIP response.
     */
    public synchronized void processSipResponse(SipResponseEvent sipResponseEvent) {
        // First check for INVITE responses
        super.processSipResponse(sipResponseEvent);

        // Then check for INFO responses
        Integer responseCode =
                sipResponseEvent.retrieveResponseCodeForMethod(Request.INFO);

        if (responseCode != null) {
            if (log.isDebugEnabled())
                log.debug("Processing INFO response");
            if ((responseCode == Response.CALL_OR_TRANSACTION_DOES_NOT_EXIST) ||
                    (responseCode == Response.REQUEST_TIMEOUT)) {
                if (log.isInfoEnabled())
                    log.info("SIP " + responseCode +
                            " response to an INFO request. The call will " +
                            "be disconnected with a SIP CANCEL request.");

                // Set call failed
                call.setStateFailed(FailedOutboundState.FailedSubState.LINGERING_CANCEL);

                call.fireEvent(new FailedEvent(
                        call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                        CallDirection.OUTBOUND,
                        "Call rejected due to " + responseCode + " response.",
                        call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        responseCode,
                        sipResponseEvent.getSipMessage().getQ850CauseLocation())));

                // Make sure the streams are deleted after the event is sent.
                // This is done to make sure that the event is generated before any
                // event generated by stream.
                call.deleteStreams();

                // Send Cancel request
                sendCancelRequest();

            } else {
                CallToCall otherCall = call.getJoinedToCall();
                if (call.isCallJoined() && (otherCall != null)) {
                    otherCall.forwardVFUResponse(sipResponseEvent);
                } else {
                    processInfoResponse(sipResponseEvent);
                }
            }
        }
    }

    /**
     * Handles a Call timeout.
     * <p>
     * If it was the {@link CallTimerTask.Type.CALL_NOT_CONNECTED} or
     * {@link CallTimerTask.Type.CALL_NOT_CONNECTED_EXTENSION} timer that
     * expired, a {@link FailedEvent} is generated, the state is set to
     * {@link FailedLingeringCancelOutboundState} and a SIP CANCEL request is
     * sent. Other timers should no expire in this state, and are ignored.
     * <br>
     * If the SIP CANCEL request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorCompletedOutboundState}.
     * @param callTimeoutEvent carries information regarding the call timeout.
     */
    public synchronized void handleCallTimeout(CallTimeoutEvent callTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("A call timeout <" + callTimeoutEvent.getType() +
                    "> was received in " + this + ".");

        Type callTimeoutEventtype = callTimeoutEvent.getType();
        if (callTimeoutEventtype == CallTimerTask.Type.CALL_NOT_CONNECTED || callTimeoutEventtype == CallTimerTask.Type.CALL_NOT_CONNECTED_EXTENSION) {

            int responseCode = Response.REQUEST_TIMEOUT;
            
            String message;
            if(callTimeoutEventtype == CallTimerTask.Type.CALL_NOT_CONNECTED) {
                message = "The \"max duration before connected\" timer has " +
                             "expired, i.e. the call was not connected in time. " +
                             "It is handled as if a SIP " + responseCode +
                             " response was received. Call is disconnected with a " +
                             "SIP CANCEL request.";
            } else {
                message = "The \"call not connected extension\" timer has " +
                        "expired, i.e. the call was not connected in time. " +
                        "It is handled as if a SIP " + responseCode +
                        " response was received. Call is disconnected with a " +
                        "SIP CANCEL request.";
            }
            if (log.isInfoEnabled()) log.info(message);

            call.setStateFailed(FailedOutboundState.FailedSubState.LINGERING_CANCEL);

            FailedEvent failedEvent = new FailedEvent(
                    call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                    CallDirection.OUTBOUND,
                    message,
                    call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        responseCode, null));
            call.fireEvent(failedEvent);

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            // Send CANCEL request
            sendCancelRequest();

        } else {
            if (log.isDebugEnabled())
                log.debug("The call timeout <" + callTimeoutEvent.getType() +
                        "> is ignored.");
        }
    }

    //===================== Private Methods =======================

    /**
     * Processes a 1xx response received for an outbound INVITE.
     * <p>
     * The response is treated as described below and the state is set to
     * {@link ProgressingProceedingOutboundState}.
     * <p>
     * <ul>
     * <li>"Trying" response:<br> Is only debug logged.
     * </li>
     * <li>"Call Is Being Forwarded" response:<br> Is only debug logged.
     * </li>
     * <li>"Queued" response:<br> Is only debug logged.
     * </li>
     * <li>"Ringing" response:<br>
     * A {@link com.mobeon.masp.callmanager.events.ProgressingEvent} is
     * generated indicating no early media.
     * </li>
     * <li>"Session Progress" response and all other 1xx responses:<br>
     * A {@link com.mobeon.masp.callmanager.events.ProgressingEvent} is
     * generated indicating early media.
     * </li>
     * <ul>
     * <p>
     * Finally, if the response is not a 100 Trying and was sent reliably, an
     * empty SIP PRACK request is generated for the response.
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process1xxResponseToInvite(SipResponseEvent sipResponseEvent) {

        // Check if response is from a forked dialog, update call with new dialog and delete outbound stream if needed
        boolean forkedDialog = handleForkedSipDialog(sipResponseEvent, true);

        int responseCode = sipResponseEvent.getResponseCode();
        
        if ((responseCode == Response.TRYING) ||
                (responseCode == Response.CALL_IS_BEING_FORWARDED) ||
                (responseCode == Response.QUEUED)) {

            if(forkedDialog) {
                call.setStateProgressing(ProgressingSubState.PROCEEDING);
            }
            
            // Trying, Call Is Being Forwarded and Queued is only logged.
            if (log.isInfoEnabled()) log.info(
                    "No special action is taken for the SIP " + responseCode +
                            " response.");

        } else if (responseCode == Response.RINGING) {
            
            if(forkedDialog) {
                call.setStateProgressing(ProgressingSubState.PROCEEDING);
            }

            ProgressingEvent progressingEvent = new ProgressingEvent(call, false);
            call.fireEvent(progressingEvent);
            if (log.isInfoEnabled()) log.info("The call is ringing.");

        } else {
            // All other SIP 1xx responses should be handled as a
            // Session Progress response
            if (log.isDebugEnabled())
                log.debug("A session progress has been received.");

            if (forkedDialog) {            
                processSessionProgressResponse(sipResponseEvent);
            } 
            else {
                // A session progress has already been received.
                // Just send a progressing event
                ProgressingEvent progressingEvent = new ProgressingEvent(call, true);
                call.fireEvent(progressingEvent);
            }
            
        }

        if ((responseCode != Response.TRYING) &&
                (call.isProvisionalResponseReliable(sipResponseEvent))) {

            // Send PRACK request
            sendPrackRequest(sipResponseEvent);

            if (log.isInfoEnabled()) log.info(
                    "PRACK is sent to acknowledge the reliable SIP " +
                            responseCode + " response.");
        }
    }

    /**
     * Processes a 2xx response received for an outbound INVITE.
     * <p>
     * The response is treated as described below:
     * <ul>
     * <li>
     * A SIP ACK request is sent using {@link #sendAckRequest()}.
     * </li>
     * <li>
     * <li>
     * A {@link ConnectedEvent} is generated and the state is set to
     * {@link ConnectedOutboundState}.
     * </li>
     * </ul>
     *
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process2xxResponseToInvite(SipResponseEvent sipResponseEvent) {

        if (log.isInfoEnabled()) log.info("A SIP final ok response is received for INVITE. " +
                                          "An ACK will be sent.");
        
        // Check if response is from a forked dialog, update call with new dialog and delete outbound stream if needed
        boolean forkedDialog = handleForkedSipDialog(sipResponseEvent, true);

        try {
            // Send ACK request
            sendAckRequest();
            if (log.isDebugEnabled())
                log.debug("SIP ACK is sent.");
            
            if(forkedDialog) {
                //forked dialog, renegotiate sdp
                
                // Retrieve and store the SDP answer
                retrieveAndStoreSdpAnswer(sipResponseEvent);

                if (log.isDebugEnabled())
                    log.debug("SDP answer is parsed.");

                // Verify that an SDP answer was included
                assertSdpAnswerExists();

                // Retrieve the SDP intersection
                SdpIntersection sdpIntersection =
                        retrieveSdpIntersection(sipResponseEvent.getResponseCode());

                if (log.isDebugEnabled())
                    log.debug("SDP answer matches outbound media types.");
                    
                //handle re-negotiated SDP on Inbound Stream
                if (log.isDebugEnabled())
                    log.debug("reNegotiatedSdpOnInboundStream");
                call.reNegotiatedSdpOnInboundStream(sdpIntersection);

                addFarEndConnection(sipResponseEvent);

                // Create the outbound stream.
                createOutboundStream(
                        sipResponseEvent.getResponseCode(), sdpIntersection);

                if (log.isDebugEnabled())
                    log.debug("Outbound stream is created.");
                
            }


            // The call is considered connected.
            call.setStateConnected();
            call.fireEvent(new ConnectedEvent(call));

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Processing 2xx response resulted in call disconnected.");
        }
        catch (SdpInternalErrorException e) {
            String message =
                    "Processing 2xx response resulted in call disconnected.";
            if (log.isDebugEnabled())
                log.debug(message, e);
        }
    }

    /**
     * Processes a 3xx response received for an outbound INVITE.
     * <p>
     * Since early media already has been setup towards the previous host, the
     * call is considered rejected using
     * {@link #callRejected(Integer, Q850CauseLocationPair)}.
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process3xxResponseToInvite(SipResponseEvent sipResponseEvent) {
        // Early media has already been set up to the previous host.
        // The call is considered rejected.
        if (log.isDebugEnabled())
            log.debug("Early media has already been set up to the previous host. " +
                    "The call is considered rejected.");
        
        // Check if response is from a forked dialog and update call with new dialog
        // Streams will be unjoined if needed in callRejected()
        handleForkedSipDialog(sipResponseEvent, false);

        callRejected(
                sipResponseEvent.getResponseCode(),
                sipResponseEvent.getSipMessage().getQ850CauseLocation());
    }

    /**
     * Processes a 5xx response received for an outbound INVITE.
     * <p>
     * Since early media already has been setup towards the previous host, the
     * call is considered rejected using
     * {@link #callRejected(Integer, Q850CauseLocationPair)}.
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process5xxResponseToInvite(SipResponseEvent sipResponseEvent) {
        // Early media has already been set up to the previous host.
        // The call is considered rejected.
        if (log.isDebugEnabled())
            log.debug("Early media has already been set up to the previous host. " +
                    "The call is considered rejected.");
        
        // Check if response is from a forked dialog and update call with new dialog
        // Streams will be unjoined if needed in callRejected()
        handleForkedSipDialog(sipResponseEvent, false);
        
        callRejected(
                sipResponseEvent.getResponseCode(),
                sipResponseEvent.getSipMessage().getQ850CauseLocation());
    }

    /**
     * Handles the detection of an abandoned stream.
     * <p>
     * In this state this is interpreted as the call being abandoned by far end.
     * The call is disconnected, i.e. a {@link FailedEvent} is generated,
     * the state is set to {@link FailedLingeringCancelOutboundState} and
     * a SIP CANCEL request is sent.
     */
    public synchronized void handleAbandonedStream() {
        if (log.isDebugEnabled())
            log.debug("A stream was detected abandoned in " + this +
                      ". The call is disconnected.");

        if (log.isInfoEnabled()) log.info(
                "A stream was detected abandoned. The call is disconnected " +
                        "with a SIP CANCEL request.");

        // Set call failed
        call.setStateFailed(FailedOutboundState.FailedSubState.LINGERING_CANCEL);

        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.FAR_END_ABANDONED,
                CallDirection.OUTBOUND, "Call rejected due to abandoned streams.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Cancel request
        sendCancelRequest();
    }

}
