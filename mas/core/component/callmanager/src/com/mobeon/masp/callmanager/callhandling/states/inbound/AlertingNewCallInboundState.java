/*
 * Copyright (c) 2005 Mobeon AB. All Rights Reserved.
 */
package com.mobeon.masp.callmanager.callhandling.states.inbound;

import gov.nist.javax.sip.header.ExtensionHeaderImpl;

import java.text.ParseException;
import java.util.Arrays;

import com.mobeon.masp.callmanager.events.ErrorEvent;
import com.mobeon.masp.callmanager.events.FailedEvent;
import com.mobeon.masp.callmanager.events.EarlyMediaAvailableEvent;
import com.mobeon.masp.callmanager.events.EarlyMediaFailedEvent;
import com.mobeon.masp.callmanager.events.ProxyingEvent;
import com.mobeon.masp.callmanager.events.RedirectedEvent;
import com.mobeon.masp.callmanager.callhandling.events.AcceptEvent;
import com.mobeon.masp.callmanager.callhandling.events.ProxyEvent;
import com.mobeon.masp.callmanager.callhandling.events.RedirectEvent;
import com.mobeon.masp.callmanager.callhandling.events.RejectEvent;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.callhandling.events.NegotiateEarlyMediaTypesEvent;
import com.mobeon.masp.callmanager.sdp.SdpMediaDescription;
import com.mobeon.masp.callmanager.sessionestablishment.PreconditionException;
import com.mobeon.masp.callmanager.sessionestablishment.UnicastException;
import com.mobeon.masp.callmanager.sip.SipConstants;
import com.mobeon.masp.callmanager.sip.events.SipRequestEvent;
import com.mobeon.masp.callmanager.sip.header.PEarlyMediaHeader;
import com.mobeon.masp.callmanager.sip.header.PEarlyMedia.PEarlyMediaTypes;
import com.mobeon.masp.callmanager.callhandling.InboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.sip.message.SipRequest;
import com.mobeon.masp.callmanager.sip.message.SipRequestFactory;
import com.mobeon.masp.callmanager.sip.message.SipResponse;
import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.CMUtils;
import com.mobeon.masp.callmanager.configuration.EarlyMediaHeaderUsage;
import com.mobeon.masp.callmanager.configuration.ReliableResponseUsage;
import com.mobeon.common.cmnaccess.oam.CommonOamManager;
import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;

import javax.sip.header.ExtensionHeader;
import javax.sip.message.Request;
import javax.sip.message.Response;

/**
 * Represents the sub state "New Call" of {@link AlertingInboundState}.
 * This sub state is entered when entering the {@link AlertingInboundState},
 * i.e. due to a new inbound call.
 * <p>
 * This sub state is entered when the initial call setup INVITE is
 * received and a provisional Trying response has been sent as response.
 * In this state, the Call Manager client can either play early media,
 * accept, proxy or reject the call.
 * <p>
 * This class is thread-safe.
 * All methods are synchronized to handle each event atomically.
 *
 * @author Malin Flodin
 */
public class AlertingNewCallInboundState extends AlertingInboundState {

    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public AlertingNewCallInboundState(InboundCallInternal call) {
        super(call);
    }

    public String toString() {
        return "Alerting state (sub state NewCall)";
    }

    /**
     * Handles an administrators lock request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * The initial inbound INVITE is rejected with a SIP
     * "Temporarily Unavailable" response.
     * <p>
     * If the SIP error response could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     */
    public synchronized void processLockRequest() {
        String message = "The Service is temporarily unavailable due to " +
                         "the current administrative state: Locked.";

        if (log.isDebugEnabled())
            log.debug("Lock requested in " + this + ". " + message);

        if (log.isInfoEnabled()) log.info(
                "Due to a lock request, the INVITE is rejected with SIP " +
                        "503 response.");

        // Set call failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, message,
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        call.sendErrorResponse(
                Response.SERVICE_UNAVAILABLE,
                call.getInitialSipRequestEvent(), message);

    }

    /**
     * This method is used when the Call Manager client accepts the inbound
     * call.
     * <p>
     * If all provisional responses shall be sent reliably:
     * <ul>
     * <li>
     * If the initial INVITE contained no SDP offer; media streams are setup
     * and an SDP offer is created using
     * {@link #setupMediaAndCreateSdpOffer()}.
     * </li>
     * <li>
     * A SIP "Ringing" response is sent reliably using
     * {@link #sendRingingResponseReliably(String)}. An SDP offer is included
     * in the response if the initial INVITE contained no SDP offer.
     * </li>
     * <li>
     * The state is set to {@link AlertingWaitForPrackInboundState}.
     * </li>
     * </ul>
     * <p>
     * Otherwise:
     * <ul>
     * <li>
     * A SIP "Ringing" response is sent unreliably using
     * {@link #sendRingingResponse()}.
     * </li>
     * <li>
     * If the initial INVITE contained an SDP offer; media streams are setup
     * and an SDP answer is created using
     * {@link #setupMediaAndCreateSdpAnswer(boolean)}.
     * </li>
     * <li>
     * If the initial INVITE did not contain an SDP offer; media streams are
     * setup and an SDP offer is created using
     * {@link #setupMediaAndCreateSdpOffer()}.
     * </li>
     * <li>
     * A SIP "OK" response with an SDP offer or answer is sent for the INVITE
     * using {@link #sendOkResponse(String)}.
     * </li>
     * <li>
     * The state is set to {@link AlertingAcceptingInboundState}.
     * </li>
     * </ul>
     *
     * @param acceptEvent carries the information regarding the accept event.
     */
    public synchronized void accept(AcceptEvent acceptEvent) {

        if (log.isDebugEnabled())
            log.debug("Accept received in " + this + ".");

        if (log.isInfoEnabled())
            log.info("The service is accepting the call.");

        // Perform pre-session establishment validation (precondition and/or unicast), if enabled.
        if (call.getConfig().isSessionEstablishmentEnabled()) {
            processPreSessionEstablishment(false);
            return;
        }
        
        // Check whether to use reliable responses or not
        ReliableResponseUsage reliableResponseUsage = call.useReliableProvisionalResponses();

        if (log.isDebugEnabled())
            log.debug("Reliable response usage: " + reliableResponseUsage);

        try {
            if (reliableResponseUsage == ReliableResponseUsage.YES) {
                // The Ringing response shall be sent reliably and the call setup will be delayed until the PRACK is received.

                // If INVITE contained no SDP offer, one must be included in the Ringing response, see RFC 3262.
                String localSdp = null;
                if (call.getRemoteSdp() == null) {
                    if (log.isDebugEnabled())
                        log.debug("SDP offer will be included in the Ringing response.");

                    localSdp = setupMediaAndCreateSdpOffer();
                } else {
                    //Create inbound stream
                    boolean doCreateOutboundStream = true;
                    if (call.isSupportForRedirectedRtpActivated()) {
                        doCreateOutboundStream = false;
                    }

                    setupMedia(doCreateOutboundStream);
                }

                // Go to Alerting Wait-for-PRACK state before sending response.
                // This is to be sure that the PRACK can be received.
                call.setStateAlerting(AlertingSubState.WAIT_FOR_PRACK);

                // Send a SIP "Ringing" response reliably
                sendRingingResponseReliably(localSdp);

                Object perf = null;
                if (CommonOamManager.profilerAgent.isProfilerEnabled()) {
                    try {
                        perf = CommonOamManager.profilerAgent.enterCheckpoint("MAS.CM.In.Sip.Req.Invite.2.Accepted");
                    } finally {
                        CommonOamManager.profilerAgent.exitCheckpoint(perf);
                    }
                }

                if (log.isDebugEnabled())
                    log.debug("Ringing response is sent reliably.");

                if (log.isDebugEnabled())
                    log.debug("Waiting for a SIP PRACK.");

            } else {

                // If INVITE contained SDP offer, the OK response will contain
                // an SDP answer. Otherwise, the OK response will contain an
                // SDP offer.
                String localSdp;
                if (call.getRemoteSdp() != null) {
                    boolean createOutboundStream = true;
                    if (call.isSupportForRedirectedRtpActivated())
                        createOutboundStream = false;

                    localSdp = setupMediaAndCreateSdpAnswer(createOutboundStream);
                } else {
                    localSdp = setupMediaAndCreateSdpOffer();
                }

                // The Ringing response is sent unreliably. The call setup
                // continues with media negotiation and sending OK response.

                // Send a SIP "Ringing" response
                sendRingingResponse();

                if (log.isDebugEnabled())
                    log.debug("Ringing response is sent.");

                // Go to Alerting Accepting state before sending response.
                // This is to be sure that the ACK can be received.
                call.setStateAlerting(AlertingSubState.ACCEPTING);

                // Send a SIP OK response
                sendOkResponse(localSdp);

                Object perf = null;
                if (CommonOamManager.profilerAgent.isProfilerEnabled()) {
                    try {
                        perf = CommonOamManager.profilerAgent.enterCheckpoint("MAS.CM.In.Sip.Req.Invite.2.Accepted");
                    } finally {
                        CommonOamManager.profilerAgent.exitCheckpoint(perf);
                    }
                }

                if (log.isDebugEnabled())
                    log.debug("Ok response is sent for INVITE.");
            }

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Accepting call failed in " + this, e);
        }
    }

    /**
     * This method is used when the Call Manager's client wants to proxy the inbound call.
     * <li>
     * The state is set to {@link AlertingProxyingInboundState}.
     * </li>
     *
     * @param proxyEvent carries the information regarding the proxy event.
     */
    public synchronized void proxy(ProxyEvent proxyEvent) {

        if (log.isDebugEnabled())
            log.debug("Proxy received in " + this + ".");

        if (proxyEvent == null || proxyEvent.getUas() == null || proxyEvent.getUas().getHost().isEmpty() || proxyEvent.getUas().getPort() == 0 ) {
            call.errorOccurred("Could not proxy the SIP INVITE, invalid proxyEvent.", false);

            // Send Server Internal Error response
            call.sendErrorResponse(Response.SERVER_INTERNAL_ERROR, call.getInitialSipRequestEvent(), null);
            return;
        }

        if (log.isInfoEnabled())
            log.info("The service is proxying the SIP INVITE request to the given UAS " + proxyEvent.getUas());

        // State must be set to Alerting.PROXYING before forwarding SIP INVITE to UAS.
        call.setStateAlerting(AlertingSubState.PROXYING);
        call.setUas(proxyEvent.getUas());

        // Update statistics
        ProxyingEvent proxyingEvent = new ProxyingEvent(call);
        call.fireEvent(proxyingEvent);

        // Create SIP INVITE (based on SIP INVITE coming from UAC) which will be sent towards UAS (given in the ProxyEvent).
        sendInviteRequest();
    }

    /**
     * This method is used when the Call Manager client wants to negotiate the
     * early media types to use prior to accepting the call.
     * <p>
     * If the initial INVITE did not contain an SDP offer, the early media
     * request is rejected and an {@link EarlyMediaFailedEvent} is generated.
     * Otherwise, the steps below are performed.
     * <p>
     * If either all provisional responses or only those carrying SDP shall be
     * sent reliably:
     * <ul>
     * <li>
     * Media streams are setup and an SDP answer is created using
     * {@link #setupMediaAndCreateSdpAnswer(boolean)}.
     * </li>
     * <li>
     * A SIP "SessionProgress" response is sent reliably using
     * {@link #sendRingingResponseReliably(String)}.
     * </li>
     * <li>
     * The state is set to {@link AlertingEarlyMediaWaitForPrackInboundState}.
     * </li>
     * </ul>
     * <p>
     * Otherwise:
     * <ul>
     * <li>
     * Media streams are setup and an SDP answer is created using
     * {@link #setupMediaAndCreateSdpAnswer(boolean)}.
     * </li>
     * <li>
     * A SIP "Session Progress" response is sent unreliably using
     * {@link #sendSessionProgressResponse(String)}.
     * </li>
     * <li>
     * An {@link EarlyMediaAvailableEvent} is generated.
     * </li>
     * <li>
     * The state is set to {@link AlertingEarlyMediaInboundState}.
     * </li>
     * </ul>
     *
     * @param event carries the information regarding the negotiation of early
     * media types.
     */
    public synchronized void negotiateEarlyMediaTypes(NegotiateEarlyMediaTypesEvent event) {

        if (log.isDebugEnabled())
            log.debug("Request to negotiate early media types was received in " + this + ".");

        if (log.isInfoEnabled())
            log.info("The service is negotiating early media types for the call.");

        if (call.getRemoteSdp() == null) {
            if (log.isInfoEnabled())
                log.info("Early media is not supported for an INVITE wihtout an SDP offer. An Early Media Failed event is generated.");
            call.fireEvent(new EarlyMediaFailedEvent(call));
            return;
        }

        if (call.isSupportForRedirectedRtpActivated()) {
            if (log.isInfoEnabled()) log.info(
                    "Early media is not supported since the INVITE " +
                    "together with configuration indicate that the " +
                    "outbound RTP streams shall be redirected. " +
                    "An Early Media Failed event is generated.");
            call.fireEvent(new EarlyMediaFailedEvent(call));
            return;
        }

        if (call.isPEarlyMediaPresentAndInactive()) {
            if (log.isInfoEnabled()) log.info(
                    "Early media is not supported since the INVITE " +
                    "contains the P-EARLY-MEDIA header with the INACTIVE value. " +
                    "An Early Media Failed event is generated.");
            call.fireEvent(new EarlyMediaFailedEvent(call));
            return;
        }

        // Perform pre-session establishment validation (precondition and/or unicast), if enabled.
        if (call.getConfig().isSessionEstablishmentEnabled()) {
            processPreSessionEstablishment(true);
            return;
        }

        // Check whether to use reliable responses or not
        ReliableResponseUsage reliableResponseUsage = call.useReliableProvisionalResponses();

        if (log.isDebugEnabled())
            log.debug("Reliable response usage: " + reliableResponseUsage);

        try {
            String sdpAnswer = setupMediaAndCreateSdpAnswer(true);

            if (reliableResponseUsage == ReliableResponseUsage.NO) {
                // The Session Progress response is sent unreliably.
                // The call setup continues with early media handling.

                // Go to Alerting Early Media Negotiated state
                call.setStateAlerting(AlertingSubState.EARLY_MEDIA);

                // Send a SIP Session Progress response
                sendSessionProgressResponse(sdpAnswer);

                if (log.isDebugEnabled())
                    log.debug("Session Progress response is sent.");

                call.fireEvent(new EarlyMediaAvailableEvent(call));
            } else {
                // The Session Progress response shall be sent reliably and the
                // call setup will be delayed until the PRACK is received.

                // Go to Alerting Wait-for-PRACK state before continuing with
                // the call setup.
                call.setStateAlerting(AlertingSubState.EARLY_MEDIA_WAIT_FOR_PRACK);

                // Send a SIP Session Progress response reliably
                sendSessionProgressResponseReliably(sdpAnswer, false);

                if (log.isDebugEnabled())
                    log.debug("Session Progress response is sent reliably.");

                if (log.isDebugEnabled())
                    log.debug("Waiting for a SIP PRACK.");
            }

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Negotiating Early Media types on call failed.");
        }
    }

    /**
     * This method is used when the Call Manager client rejects the inbound
     * call.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "Forbidden" response is sent for the initial INVITE.
     * <p>
     * If the SIP response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param rejectEvent carries the information regarding the reject event.
     */
    public synchronized void reject(RejectEvent rejectEvent) {
        if (log.isDebugEnabled())
            log.debug("Reject received in " + this + ". ");

        if (log.isInfoEnabled())
            log.info("The service is rejecting the call. A SIP " + rejectEvent.getCode() + " response will be sent.");

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, rejectEvent.getMessage(),
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        call.sendErrorResponse(rejectEvent.getCode(), call.getInitialSipRequestEvent(), rejectEvent.getMessage());
    }



    /**
     * This method is use when CallManager client redirects the inbound call
     * A corresponding SIP 3XX  response is sent for the initial INVITE.
     * <p>
     * If the SIP response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     */
    public void redirect(RedirectEvent redirectEvent) {
        if (log.isDebugEnabled())
            log.debug("Redirect received in " + this + ". ");

        if (log.isInfoEnabled())
            log.info("The service is redirecting the call. A SIP " + redirectEvent.getRedirectCode().getCode() + " response will be sent.");

        //Set state to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new RedirectedEvent(call,null));


        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();
        call.sendRedirectResponse(redirectEvent.getDestination(),redirectEvent.getRedirectCode(),call.getInitialSipRequestEvent());

    }

    /**
     * Handles a SIP BYE request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "Request Terminated" response is sent for the pending INVITE request.
     * A SIP "OK" is sent as response to the BYE request.
     * <p>
     * If a SIP response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param sipRequestEvent carries the SIP BYE request.
     */
    public synchronized void processBye(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP BYE request received in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "The far end has disconnected the call with a SIP BYE request.");

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                CallDirection.INBOUND, "Call disconnected early by far end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null,
                        sipRequestEvent.getSipMessage().getQ850CauseLocation())));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Request Terminated response to initial INVITE
        call.sendErrorResponse(
                Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(),
                "Call terminated due to a BYE request.");

        // Send OK response to BYE request
        call.sendOkResponse(sipRequestEvent, true);
    }

    /**
     * Handles a SIP CANCEL request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "Request Terminated" response is sent for the pending INVITE request.
     * A SIP "OK" is sent as response to the CANCEL request.
     * <p>
     * If a SIP response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param sipRequestEvent carries the SIP CANCEL request.
     */
    public synchronized void processCancel(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP CANCEL received in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "The far end has canceled the call with a SIP CANCEL request.");

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                CallDirection.INBOUND, "Call disconnected early by far end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null,
                        sipRequestEvent.getSipMessage().getQ850CauseLocation())));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Request Terminated response to initial INVITE
        call.sendErrorResponse(
                Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(),
                "Call terminated due to a BYE request.");

        // Send OK response to CANCEL request
        call.sendOkResponse(sipRequestEvent, true);
    }

    /**
     * Handles a Call timeout.
     * <p>
     * If it was the {@link CallTimerTask.Type.CALL_NOT_ACCEPTED} timer that
     * expired, a {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * Other timers should no expire in this state, and are ignored.
     * @param callTimeoutEvent carries information regarding the call timeout.
     */
    public synchronized void handleCallTimeout(CallTimeoutEvent callTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("A call timeout <" + callTimeoutEvent.getType() +
                    "> was received in " + this + ".");

        int nsc = call.getConfig().getReleaseCauseMapping().
                getNetworkStatusCode(null, null);

        if (callTimeoutEvent.getType() == CallTimerTask.Type.CALL_NOT_ACCEPTED) {
            String message = "The inbound call was not accepted by the service " +
                             "in time. It is considered abandoned and a SIP 408 " +
                             "response will be sent.";
            if (log.isInfoEnabled()) log.info(message);

            // Set call to failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
            call.fireEvent(new FailedEvent(
                    call, FailedEvent.Reason.NEAR_END_ABANDONED,
                    CallDirection.INBOUND, message, nsc));

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            call.sendErrorResponse(
                    Response.REQUEST_TIMEOUT, call.getInitialSipRequestEvent(),
                    "Call was not accepted in time.");

        } else if (callTimeoutEvent.getType() == CallTimerTask.Type.EXPIRES) {
            String message = "The expires timer expired for the INVITE. " +
                             "A SIP 487 response will be sent.";
            if (log.isInfoEnabled()) log.info(message);

            // Set call to failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
            call.fireEvent(new FailedEvent(
                    call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                    CallDirection.INBOUND, message, nsc));

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            call.sendErrorResponse(
                    Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(),
                    "Expires timer expired.");

        } else {
            if (log.isDebugEnabled())
                log.debug("The call timeout <" + callTimeoutEvent.getType() +
                        "> is ignored.");
        }
    }


    //========================= Private methods ===========================

    /**
     * Sends a SIP INVITE request to UAC based on the initial INVITE request.
     * <p>
     * If the SIP INVITE request could not be sent, the error is logged,
     * an {@link ErrorEvent} is generated and the state is set to {@link ErrorInboundState}.
     * @throws IllegalStateException if the SIP request could not be sent.
     */
    private void sendInviteRequest() throws IllegalStateException {

        try {
            // Create SipUri based on the given OPCO
            SipRequestFactory srf = CMUtils.getInstance().getSipRequestFactory();
            SipRequestEvent sre = call.getInitialSipRequestEvent();

            SipRequest uasSipInviteRequest = srf.createSipRequest(call.getUas(), sre);

            if (uasSipInviteRequest != null) {
                // Send the uasSipInviteRequest
                sipMessageSender.sendRequestStatelessly(uasSipInviteRequest);
            }

        } catch (Exception e) {
            if(log.isInfoEnabled()) {
                log.info("Exception: " + e);
            }
            call.errorOccurred("UAS SIP INVITE request could not be created. " + e.getMessage(), false);
            throw(new IllegalStateException());
        }
    }

    /**
     * Sends a SIP "Ringing" response for the initial INVITE request.
     * <p>
     * If the SIP "Ringing" response could not be sent, the error is logged,
     * an {@link ErrorEvent} is generated and the state is set to
     * {@link ErrorInboundState}.
     * @throws IllegalStateException if the SIP response could not be sent.
     */
    private void sendRingingResponse() throws IllegalStateException {
        try {
            SipResponse sipResponse =
                    sipResponseFactory.createRingingResponse(
                            call.getInitialSipRequestEvent(),
                            null, call.getConfig().getRegisteredName(), false);
            processPEarlyMediaInInitialRequest(sipResponse, false);
            sipMessageSender.sendResponse(sipResponse);

        } catch (Exception e) {
            call.errorOccurred(
                    "Could not send SIP \"Ringing\" response: " + e.getMessage(),
                    false);
            throw(new IllegalStateException());
        }
    }

    /**
     * Sends a reliable SIP "Ringing" response for the initial INVITE request.
     * <p>
     * If the SIP "Ringing" response could not be sent, the error is logged,
     * an {@link ErrorEvent} is generated and the state is set to
     * {@link ErrorInboundState}.
     *
     * @param sdp       The SDP to include in the response. Can be null
     *                  if no SDP shall be included in the response.
     * @throws IllegalStateException if the SIP response could not be sent.
     */
    private void sendRingingResponseReliably(String sdp)
            throws IllegalStateException {
        try {
            SipResponse sipResponse =
                    sipResponseFactory.createRingingResponse(
                            call.getInitialSipRequestEvent(),
                            sdp,
                            call.getConfig().getRegisteredName(),
                            true);
            processPEarlyMediaInInitialRequest(sipResponse, false);
            sipMessageSender.sendReliableProvisionalResponse(
                    call.getDialog(), sipResponse);

        } catch (Exception e) {
            call.errorOccurred(
                    "Could not send reliable SIP \"Ringing\" response: " +
                            e.getMessage(),
                    false);
            throw(new IllegalStateException());
        }
    }

    /**
     * Sends a SIP "Session Progress" response for the initial INVITE request
     * containing an SDP Answer indicating that early media is available.
     * <p>
     * If the SIP "Session Progress" response could not be sent, an error is
     * reported.
     * @param sdpAnswer The SDP answer sent in the response body.
     * @throws IllegalStateException if the SIP response could not be sent.
     */
    protected void sendSessionProgressResponse(String sdpAnswer)
            throws IllegalStateException {

        try {
            SipResponse sipResponse =
                    CMUtils.getInstance().getSipResponseFactory().
                            createSessionProgressResponse(
                                    call.getInitialSipRequestEvent(),
                                    sdpAnswer,
                                    call.getConfig().getRegisteredName(), false, false, false);

            addProprietaryHeadersFromApplication(sipResponse, PROPRIETARY_HEADER_FOR_SESSION_PROGRESS_RESPONSE);
            processPEarlyMediaInInitialRequest(sipResponse, true);
            sipMessageSender.sendResponse(sipResponse);

        } catch (Exception e) {
            String errorMessage =
                    "Could not send SIP \"Session Progress\" response: " +
                            e.getMessage();
            call.errorOccurred(errorMessage, false);
            throw(new IllegalStateException());
        }
    }

    /**
     * Sends a reliable SIP "Session Progress" response for the initial INVITE
     * request containing an SDP Answer indicating that early media is available.
     * <p>
     * If the SIP "Session Progress" response could not be sent, an error is
     * reported.
     * @param sdpAnswer The SDP answer sent in the response body
     * @param update Indicates if the response must contain UPDATE method in the Allow header
     * @throws IllegalStateException if the SIP response could not be sent.
     */
    protected void sendSessionProgressResponseReliably(String sdpAnswer, boolean update) throws IllegalStateException {

        try {
            SipResponse sipResponse =
                    CMUtils.getInstance().getSipResponseFactory().
                            createSessionProgressResponse(
                                    call.getInitialSipRequestEvent(),
                                    sdpAnswer,
                                    call.getConfig().getRegisteredName(),
                                    true,
                                    false,
                                    call.getPreconditionStatusTable().isPreconditionRequire());

            addProprietaryHeadersFromApplication(sipResponse, PROPRIETARY_HEADER_FOR_SESSION_PROGRESS_RESPONSE);
            processPEarlyMediaInInitialRequest(sipResponse, true);
            addUpdateMethodInAllowHeader(sipResponse, update);

            sipMessageSender.sendReliableProvisionalResponse(call.getDialog(), sipResponse);

        } catch (Exception e) {
            String errorMessage = "Could not send reliable SIP \"Session Progress\" response: " + e.getMessage();
            call.errorOccurred(errorMessage, false);
            throw(new IllegalStateException());
        }
    }

    private void addUpdateMethodInAllowHeader(SipResponse sipResponse, boolean update) throws ParseException {
        if (update) {
            sipResponse.addAllowHeader(Request.UPDATE);
        }
    }

    /**
     * This method handles session establishment (preconditions and/or unicast) validation and setup.
     * 
     * <p>
     * Even in the scenario of already-fulfilled preconditions and/or unicast,
     * this method still MUST handle the case since specific attributes MUST be in the response.
     * 
     * @param earlyMedia true if the Call Manager client requires to negociateEarlyMedia, false otherwise.
     */
    private void processPreSessionEstablishment(boolean earlyMedia) {
        boolean preconditionsFulfilled = true;
        boolean unicastFulfilled = true;
        String sdpAnswer = null;

        boolean preconditionRequired = call.getInitialSipRequestEvent().getSipMessage().isRequired(SipConstants.EXTENSION_PRECONDITION);
        boolean preconditionSupported = call.getInitialSipRequestEvent().getSipMessage().isSupported(SipConstants.EXTENSION_PRECONDITION);
        boolean _100reliableRequired = call.getInitialSipRequestEvent().getSipMessage().isRequired(SipConstants.EXTENSION_100REL);
        boolean _100reliableSupported = call.getInitialSipRequestEvent().getSipMessage().isSupported(SipConstants.EXTENSION_100REL);
        boolean _100reliable = _100reliableRequired || _100reliableSupported;

        try {
            call.setEarlyMediaRequested(earlyMedia);

            // Find SDP intersection and create inbound stream
            setupMedia(false);

            int index = call.getSdpIntersection().getAudioIndex();
            SdpMediaDescription smd = call.getSdpIntersection().getSessionDescription().getMediaDescription(index);

            // Precondition validation
            if (call.getConfig().isPreconditionEnabled()) {
                preconditionsFulfilled = call.getPreconditionStatusTable().update(smd, preconditionRequired, preconditionSupported, _100reliable);
            }

            // Unicast validation
            if (call.getConfig().isUnicastEnabled()) {
                unicastFulfilled = call.getUnicastStatus().update(smd, _100reliable);
            }

            // Generate SDP answer which will contain precondition/unicast attribtes
            sdpAnswer = createSdpAnswerFromIntersection(call.getSdpIntersection(), call.getInboundConnectionProperties());

            /**
             * 1) Outbound stream cannot be created until preconditions are met.
             * 2) Unicast does not impose such restriction, meaning that outbound stream can be created regardless of it's status.
             * Therefore, only preconditions must be checked
             */
            if (preconditionsFulfilled) {
                call.createOutboundStream(call.getSdpIntersection());
            }

            if (preconditionsFulfilled && unicastFulfilled) {
                if (log.isDebugEnabled())
                    log.debug("Pre-session establishment condition(s) fulfilled");

                if (_100reliable) {
                    if (earlyMedia) {
                        call.setStateAlerting(AlertingSubState.EARLY_MEDIA_WAIT_FOR_PRACK);

                        // Send a SIP Session Progress response reliably
                        sendSessionProgressResponseReliably(sdpAnswer, false);

                        // Reset flag stating if the response MUST contain a Require header with the 'precondition' option tag and 
                        // the precondition status table in the SDP answer after sending the response
                        call.getPreconditionStatusTable().resetPreconditionRequire();

                        if (log.isDebugEnabled())
                            log.debug("Session Progress response is sent reliably.");

                        if (log.isDebugEnabled())
                            log.debug("Waiting for a SIP PRACK.");
                    } else {
                        // Everything fulfilled - no need to send session progress, send ringing directly
                        call.setStateAlerting(AlertingSubState.WAIT_FOR_PRACK);

                        // Send a SIP "Ringing" response reliably
                        sendRingingResponseReliably(sdpAnswer);
                        
                        // Reset flag stating if the response MUST contain a Require header with the 'precondition' option tag and 
                        // the precondition status table in the SDP answer after sending the response
                        call.getPreconditionStatusTable().resetPreconditionRequire();
                        
                        Object perf = null;
                        if (CommonOamManager.profilerAgent.isProfilerEnabled()) {
                            try {
                                perf = CommonOamManager.profilerAgent.enterCheckpoint("MAS.CM.In.Sip.Req.Invite.2.Accepted");
                            } finally {
                                CommonOamManager.profilerAgent.exitCheckpoint(perf);
                            }
                        }

                        if (log.isDebugEnabled())
                            log.debug("Ringing response is sent reliably.");

                        if (log.isDebugEnabled())
                            log.debug("Waiting for a SIP PRACK.");
                    }
                } else {
                    if (earlyMedia) {
                        // The Session Progress response is sent unreliably.
                        // The call setup continues with early media handling.

                        // Go to Alerting Early Media Negotiated state
                        call.setStateAlerting(AlertingSubState.EARLY_MEDIA);

                        // Send a SIP Session Progress response
                        sendSessionProgressResponse(sdpAnswer);

                        if (log.isDebugEnabled())
                            log.debug("Session Progress response is sent.");

                        call.fireEvent(new EarlyMediaAvailableEvent(call));
                    } else {
                        // Everything fulfilled - no need to send session progress, send ringing directly
                        // The Ringing response is sent unreliably. The call setup
                        // continues with media negotiation and sending OK response.

                        // Send a SIP "Ringing" response
                        sendRingingResponse();

                        if (log.isDebugEnabled())
                            log.debug("Ringing response is sent.");

                        // Go to Alerting Accepting state before sending response.
                        // This is to be sure that the ACK can be received.
                        call.setStateAlerting(AlertingSubState.ACCEPTING);

                        // Send a SIP OK response
                        sendOkResponse(sdpAnswer);

                        Object perf = null;
                        if (CommonOamManager.profilerAgent.isProfilerEnabled()) {
                            try {
                                perf = CommonOamManager.profilerAgent.enterCheckpoint("MAS.CM.In.Sip.Req.Invite.2.Accepted");
                            } finally {
                                CommonOamManager.profilerAgent.exitCheckpoint(perf);
                            }
                        }

                        if (log.isDebugEnabled())
                            log.debug("Ok response is sent for INVITE.");
                        
                    }
                }
            } else {
                if (log.isDebugEnabled())
                    log.debug("Session establishment conditions not fulfilled (precondition: " + preconditionsFulfilled + ", unicast: " + unicastFulfilled + "), still pending");

                call.setStateAlerting(AlertingSubState.SESSION_ESTABLISHMENT_WAIT_FOR_PRACK);

                // Send a SIP Session Progress response reliably
                sendSessionProgressResponseReliably(sdpAnswer, true);

                // Reset flag stating if the response MUST contain a Require header with the 'precondition' option tag and 
                // the precondition status table in the SDP answer after sending the response
                call.getPreconditionStatusTable().resetPreconditionRequire();

                if (log.isDebugEnabled())
                    log.debug("Session Progress response is sent reliably.");

                if (log.isDebugEnabled())
                    log.debug("Waiting for a SIP PRACK.");
            }

        } catch (PreconditionException pe) {
            handleError(pe.getExceptionCause().getSipErrorCode(), pe.getAdditionalInfo(), call.getInitialSipRequestEvent());
        } catch (UnicastException ue) {
            handleError(ue.getUnicastExceptionCause().getSipErrorCode(), ue.getAdditionalInfo(), call.getInitialSipRequestEvent());
        } catch (IllegalStateException ise) {
            // Methods that thrown IllegalStateException already sends back an error to UAc and deleted streams.
            log.error("IllegalStateException: " + ise.getMessage(), ise);
        } catch (Exception e) {
            log.error("Exception: " + e.getMessage(), e);
            handleError(Response.SERVER_INTERNAL_ERROR, null, call.getInitialSipRequestEvent());
        }

        return;
    }

}
