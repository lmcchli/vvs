/*
 * Copyright (c) 2005 Mobeon AB. All Rights Reserved.
 */
package com.mobeon.masp.callmanager.callhandling.states.inbound;

import com.mobeon.masp.callmanager.callhandling.InboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.callhandling.events.DisconnectEvent;
import com.mobeon.masp.callmanager.callhandling.events.PlayEvent;
import com.mobeon.masp.callmanager.callhandling.events.StopPlayEvent;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.sip.events.SipRequestEvent;
import com.mobeon.masp.callmanager.sip.events.SipTimeoutEvent;
import com.mobeon.masp.callmanager.events.ConnectedEvent;
import com.mobeon.masp.callmanager.events.FailedEvent;
import com.mobeon.masp.callmanager.events.ErrorEvent;
import com.mobeon.masp.callmanager.events.DisconnectedEvent;
import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.CallProperties;
import com.mobeon.masp.callmanager.sdp.SdpInternalErrorException;
import com.mobeon.masp.callmanager.sdp.SdpIntersection;
import com.mobeon.masp.callmanager.sdp.SdpNotSupportedException;
import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;

/**
 * Represents the sub state "Accepting" of {@link AlertingInboundState}.
 * This sub state is entered when the Call Manager client accepts the inbound
 * call.
 * <p>
 * In this state a final OK response has been sent for the initial INVITE.
 * In this state, the Call Manager client can only disconnect the call.
 * <p>
 * All methods are synchronized to handle each event atomically.
 *
 * @author Malin Flodin
 */
public class AlertingAcceptingInboundState extends AlertingInboundState {

    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public AlertingAcceptingInboundState(InboundCallInternal call) {
        super(call);
    }

    public String toString() {
        return "Alerting state (sub state Accepting)";
    }

    /**
     * Handles an administrators lock request.
     * <p>
     * Since the initial INVITE has not yet been acknowledged, a BYE request
     * cannot be sent. The BYE request is not sent until the SIP ACK has been
     * received. But, the call is considered completed anyway.
     * A {@link FailedEvent} is generated amd the state is set to
     * {@link FailedWaitingForAckInboundState} where it is waiting for the
     * SIP ACK so that a SIP BYE request can be sent to disconnect the call.
     */
    public synchronized void processLockRequest() {
        if (log.isDebugEnabled()) {
            log.debug("Lock is requested while in " + this +
                      ". This Lock request will not send a BYE request " +
                      "until the INVITE has been acknowledged.");
        }

        if (log.isInfoEnabled()) log.info(
                "Due to a lock request, the call will be disconnected with a " +
                        "SIP BYE request as soon as the SIP ACK request " +
                        "has been received.");

        // Set call failed
        call.setStateFailed(FailedInboundState.FailedSubState.WAITING_FOR_ACK);
        String message = "The Service is temporarily unavailable due to " +
                         "the current administrative state: Locked.";
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, message, call.getConfig().
                getReleaseCauseMapping().getNetworkStatusCode(null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();
    }

    /**
     * This method is used when the Call Manager client disconnects the call.
     * <p>
     * Since the initial INVITE has not yet been acknowledged, a BYE request
     * cannot be sent. The BYE request is not sent until the SIP ACK has been
     * received. But, the call is considered completed anyway.
     * A {@link FailedEvent} is generated amd the state is set to
     * {@link FailedWaitingForAckInboundState} where it is waiting for the
     * SIP ACK so that a SIP BYE request can be sent to disconnect the call.
     *
     * @param disconnectEvent carries the information regarding the disconnect.
     */
    public synchronized void disconnect(DisconnectEvent disconnectEvent) {
        if (log.isDebugEnabled()) {
            log.debug("Disconnect is requested while in " + this +
                      ". This Disconnect request will not send a BYE request " +
                      "until the INVITE has been acknowledged.");
        }

        if (log.isInfoEnabled()) log.info(
                "The service is disconnecting the call. A SIP BYE request " +
                        "will be sent as soon as the SIP ACK request " +
                        "has been received.");

        // Set call failed
        call.setStateFailed(FailedInboundState.FailedSubState.WAITING_FOR_ACK);
        String message = "A disconnect is requested before the call is connected.";
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, message, call.getConfig().
                getReleaseCauseMapping().getNetworkStatusCode(null, null)));

        // This is because EE expects one event per called method, but it
        // does not conform with the CCXML standard
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.NEAR_END, true));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();
    }

    /**
     * Handles a request to play media.
     * The media is played on the outbound stream of the call using
     * {@link InboundCallInternal#playOnOutboundStream(PlayEvent)}.
     * @param playEvent carries information regarding the play request.
     */
    public synchronized void play(PlayEvent playEvent) {
        if (log.isDebugEnabled()) {
            log.debug("Request to play media was received in " + this + ".");
        }
        call.logPlayTime();
        call.playOnOutboundStream(playEvent);
    }

    /**
     * Handles a request to stop an ogoing play.
     * The ongoing play (if any) is stopped using
     * {@link InboundCallInternal#stopOngoingPlay(StopPlayEvent)}.
     * @param stopPlayEvent
     */
    public synchronized void stopPlay(StopPlayEvent stopPlayEvent) {
        if (log.isDebugEnabled()) {
            log.debug("Request to stop an ongoing play was received in " +
                    this + ".");
        }
        call.stopOngoingPlay(stopPlayEvent);
    }

    /**
     * Handles a SIP ACK request.
     * <p>
     * If the initial INVITE did not contain an SDP offer, the ACK is treated
     * as described in the bullet list below:
     * <ul>
     * <li>
     * The SDP Answer (if any) is retrieved, parsed and stored in the call
     * using {@link #retrieveAndStoreSdpAnswer(SipRequestEvent)}.
     * </li>
     * <li>
     * A check is made to verify that the SDP Answer was stored ok in the call
     * using {@link #assertSdpAnswerExists()}.
     * </li>
     * <li>
     * An SDP intersection between the SDP offer in the initial INVITE and the
     * SDP answer is located using {@link #retrieveSdpIntersection()}.
     * </li>
     * <li>
     * If RTP redirection is not activated, an outbound media stream is created using
     * {@link #createOutboundStream(SdpIntersection)}.
     * </li>
     * </ul>
     * If RTP redirection is not activated, the call is now considered connected
     * and a {@link ConnectedEvent} is generated and the state is set to
     * {@link ConnectedInboundState}.
     *
     * @param sipRequestEvent carries the SIP ACK request.
     */
    public synchronized void processAck(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled()) {
            log.debug("SIP ACK request received in " + this + ".");
        }


        boolean isSupportForRedirectedRtpActivated =
            call.isSupportForRedirectedRtpActivated();

        try {
            if (call.getRemoteSdp() == null) {
                if (log.isInfoEnabled()) log.info(
                        "SIP ACK request is received. Media negotiation is " +
                                "initiated.");

                if (log.isDebugEnabled())
                    log.debug("SDP answer should be included in the SIP ACK.");

                // Retrieve and store the SDP answer
                retrieveAndStoreSdpAnswer(sipRequestEvent);

                if (log.isDebugEnabled())
                    log.debug("SDP answer is parsed.");

                // Verify that an SDP answer was included
                assertSdpAnswerExists();

                // Retrieve the SDP intersection
                SdpIntersection sdpIntersection = retrieveSdpIntersection();

                if (log.isDebugEnabled())
                    log.debug("SDP answer matches outbound media types.");

                // Create the outbound stream.
                if (!isSupportForRedirectedRtpActivated) {
                    createOutboundStream(sdpIntersection);
                    if (log.isDebugEnabled())
                        log.debug("Outbound stream is created.");
                }
            }

            // If RTP redirection is not activated, set call connected
            // Otherwise, start waiting for call hold
            if (!isSupportForRedirectedRtpActivated) {
                if (log.isInfoEnabled()) log.info(
                    "SIP ACK request is received. The call is now connected.");
                call.setStateConnected();
                call.fireEvent(new ConnectedEvent(call));
            } else {
                if (log.isInfoEnabled()) log.info(
                    "SIP ACK request is received. Waiting for call hold " +
                    "and redirected RTP in re-INVITEs.");
                call.setStateAlerting(AlertingSubState.WAIT_FOR_CALL_HOLD);
            }

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Call acknowledgement failed.");
        }
    }

    /**
     * Handles a SIP BYE request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "OK" is sent as response to the BYE request.
     * <p>
     * If the response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param sipRequestEvent carries the SIP BYE request.
     */
    public synchronized void processBye(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP BYE request received in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "The far end has disconnected the call with a SIP BYE request.");

        // Set call failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                CallDirection.INBOUND, "Call disconnected early by far end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null,
                        sipRequestEvent.getSipMessage().getQ850CauseLocation())));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send OK response for BYE request
        call.sendOkResponse(sipRequestEvent, true);
    }

    /**
     * Handles a SIP CANCEL request.
     * <p>
     * A CANCEL in this state means that no cancellation is performed since a
     * final response already has been sent for the initial INVITE request.
     * A SIP "OK" is sent as response to the CANCEL request.
     * The state is left unchanged.
     * <p>
     * If the response could not be sent, the state
     * is set to {@link ErrorInboundState} and an {@link ErrorEvent}
     * is generated.
     *
     * @param sipRequestEvent carries the SIP CANCEL request.
     */
    public synchronized void processCancel(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP CANCEL request was received in " + this + ". " +
                    "No cancellation is performed since a final response " +
                    "already has been sent for the initial INVITE request.");

        if (log.isInfoEnabled()) log.info(
                "A SIP CANCEL is received when a final response has been sent " +
                        "for the INVITE. No cancellation is performed.");

        call.sendOkResponse(sipRequestEvent, false);
    }

    /**
     * Handles a SIP timeout event.
     * <p/>
     * A BYE request is sent and the state is set to
     * {@link ErrorInboundState.ErrorSubState.LINGERING_BYE}.
     *
     * @param sipTimeoutEvent carries information regarding the timeout event.
     */
    public synchronized void processSipTimeout(SipTimeoutEvent sipTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP timeout expired in " + this + ".");

        call.setStateError(ErrorInboundState.ErrorSubState.LINGERING_BYE);
        call.fireEvent(new ErrorEvent(
                call, CallDirection.INBOUND,
                "SIP timeout occurred while waiting for ACK. " +
                        "The call will be ended with a SIP BYE request.", false));
        call.deleteStreams();
        sendByeRequest();
    }

    /**
     * Handles a Call timeout.
     * <p/>
     * If the call timeout is of type {@link CallTimerTask.Type.NO_ACK}, an
     * {@link ErrorEvent} is generated and the state is set to
     * {@link ErrorLingeringByeInboundState}.
     */
    public synchronized void handleCallTimeout(CallTimeoutEvent callTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("A call timeout <" + callTimeoutEvent.getType() +
                    "> was received in " + this + ".");

        if (callTimeoutEvent.getType() == CallTimerTask.Type.NO_ACK) {
            String message = "The inbound call has timed out while waiting " +
                    "for an ACK. The call is considered disconnected.";

            if (log.isInfoEnabled()) log.info(message + " CalledParty: " +
                    call.getCalledParty().toString()
                    + " dialogId=" + call.getInitialDialogId());

            call.setStateError(ErrorInboundState.ErrorSubState.COMPLETED);
            call.fireEvent(new ErrorEvent(
                    call, CallDirection.INBOUND, message, false));
            call.deleteStreams();
        } else {
            if (log.isDebugEnabled())
                log.debug("The call timeout <" + callTimeoutEvent.getType() +
                        "> is ignored.");
        }
    }


    //===================== Private Methods =======================


    /**
     * Verifies that the SDP answer stored in the call is not null.
     * <p>
     * If the SDP answer is null, a {@link FailedEvent} is generated, the
     * state is set to {@link FailedLingeringByeInboundState} and a SIP
     * BYE request is sent.
     * <br>
     * If the SIP BYE request cannot be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     * @throws IllegalStateException if the SDP answer is null.
     */
    protected void assertSdpAnswerExists() throws IllegalStateException {
        if (call.getRemoteSdp() == null) {
            String message = "The SIP ACK contained no SDP answer.";

            if (log.isInfoEnabled()) log.info(message +
                    " Call is disconnected with a SIP BYE request.");

            call.setStateFailed(FailedInboundState.FailedSubState.LINGERING_BYE);

            call.fireEvent(new FailedEvent(
                    call, FailedEvent.Reason.MEDIA_NEGOTIATION_FAILED,
                    CallDirection.INBOUND, message,
                    call.getConfig().
                    getReleaseCauseMapping().getNetworkStatusCode(null, null)));


            // Send BYE request
            sendByeRequest();

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();


            throw(new IllegalStateException());
        }
    }

    /**
     * Creates an outbound stream based on an SDP intersection.
     * <p>
     * If the stream could not be created, the call is disconnected and an
     * {@link ErrorEvent} is generated. The state is set to
     * {@link ErrorLingeringByeInboundState} and a SIP BYE request is sent.
     * <br>
     * If the SIP BYE request cannot be sent, an error is reported.
     * @param sdpIntersection
     * @throws IllegalStateException if the stream could not be created.
     */
    protected void createOutboundStream(SdpIntersection sdpIntersection)
            throws IllegalStateException {
        // Create the outbound stream. If error at creation,
        // disconnect the call
        try {
            call.createOutboundStream(sdpIntersection);
        } catch (Exception e) {
            String message =
                    "Could not create outbound stream: " + e.getMessage() +
                    ". Call is disconnected with a SIP BYE request.";
            if (log.isInfoEnabled()) log.info(message);

            call.setStateError(ErrorInboundState.ErrorSubState.LINGERING_BYE);

            call.fireEvent(new ErrorEvent(
                    call, CallDirection.INBOUND, message, false));

            // Send BYE request
            sendByeRequest();


            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            throw(new IllegalStateException());
        }
    }

    /**
     * Retrieves the SDP Answer from the SIP request and stores it in the call.
     * <p>
     * If an error occurred when retrieving the SDP answer, an {@link ErrorEvent}
     * is generated, the state is set to {@link ErrorLingeringByeInboundState}
     * and a SIP BYE request is sent.
     * <br>
     * If the SIP BYE request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     * @param sipRequestEvent
     * @throws IllegalStateException if an error occurred while retrieving the
     * SDP answer.
     */
    protected void retrieveAndStoreSdpAnswer(SipRequestEvent sipRequestEvent)
            throws IllegalStateException {
        try {
            call.parseRemoteSdp(sipRequestEvent.getSipMessage());

        } catch (SdpNotSupportedException e) {
            String message =
                    "Could not parse remote SDP answer: " + e.getMessage() +
                    ". Call is disconnected with a SIP BYE request.";
            if (log.isInfoEnabled()) log.info(message);
            call.setStateError(ErrorInboundState.ErrorSubState.LINGERING_BYE);
            call.fireEvent(new ErrorEvent(
                    call, CallDirection.INBOUND, message, false));

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            // Send BYE request
            sendByeRequest();
            throw(new IllegalStateException());
        }
    }

    /**
     * Tries to find a match between the offered SDP (included in the
     * OK response) and the SDP answer included in the SIP ACK.
     * <p>
     * If no SDP intersection was found, the call is disconnected and a
     * {@link FailedEvent} is generated. The state is set to
     * {@link FailedLingeringByeInboundState} and a SIP BYE request is sent.
     * <br>
     * If the SIP BYE request cannot be sent, an error is reported.
     * @return the SDP intersection which is never null.
     * @throws IllegalStateException if an SDP intersection could not be found.
     */
    protected SdpIntersection retrieveSdpIntersection()
            throws IllegalStateException {

        CallProperties.CallType currentCallType = call.getCallType();
        SdpIntersection sdpIntersection =null;
        try
        {
            sdpIntersection=call.findSdpIntersection(call.getOutboundCallMediaTypes(), false);
        }
        catch (SdpInternalErrorException e)
        {
            log.error("");
        }


        // If no SDP intersection was found, the call is disconnected
        if ((sdpIntersection == null) ||
                (currentCallType!= sdpIntersection.getCallType())) {

            String message = "Media negotiation failed.";
            if ((sdpIntersection != null) &&
                (call.getCallType() != sdpIntersection.getCallType())) {
                message += " The call type (" + call.getCallType() +
                           ") did not match the type of the SDP intersection (" +
                           sdpIntersection.getCallType() + ").";
            }
            message += " Call is disconnected with a SIP BYE request.";
            if (log.isInfoEnabled()) log.info(message);

            call.setStateFailed(FailedInboundState.FailedSubState.LINGERING_BYE);

            call.fireEvent(new FailedEvent(
                    call, FailedEvent.Reason.MEDIA_NEGOTIATION_FAILED,
                    CallDirection.INBOUND, message, call.getConfig().
                    getReleaseCauseMapping().getNetworkStatusCode(null, null)));

            // Send BYE request
            sendByeRequest();

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            throw(new IllegalStateException());
        }

        return sdpIntersection;
    }

}
