/*
 * Copyright (c) 2006 Mobeon AB. All Rights Reserved.
 */
package com.mobeon.masp.callmanager.callhandling.states.outbound;

import com.mobeon.masp.callmanager.callhandling.OutboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.events.FailedEvent;
import com.mobeon.masp.callmanager.events.ProgressingEvent;
import com.mobeon.masp.callmanager.events.ConnectedEvent;
import com.mobeon.masp.callmanager.events.DisconnectedEvent;
import com.mobeon.masp.callmanager.callhandling.events.DisconnectEvent;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.sip.events.SipResponseEvent;
import com.mobeon.masp.callmanager.sdp.SdpIntersection;
import com.mobeon.masp.callmanager.sdp.SdpInternalErrorException;
import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.releasecausemapping.Q850CauseLocationPair;
import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;

import javax.sip.message.Response;
import javax.sip.address.SipURI;

/**
 * A substate of the outbound state Progressing.
 * <p>
 * This state is entered when the initial INVITE is sent but no response has
 * been received.
 * <p>
 * All methods are synchronized to handle each event atomically.
 *
 * @author Malin Flodin
 */
public class ProgressingCallingOutboundState extends ProgressingOutboundState {

    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public ProgressingCallingOutboundState(OutboundCallInternal call) {
        super(call);
    }

    public String toString() {
        return "Progressing state (sub state Calling)";
    }

    /**
     * Handles an administrators lock request.
     * <p>
     * Since a provisional response has not yet been received for the initial
     * outbound INVITE, a CANCEL request cannot be sent. The call is not
     * disconnected until a provisional or final response is received. If a
     * provisional response is received, a CANCEL request is sent.
     * If a final response is received, a BYE request is sent after the call
     * has been acknowledged.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedWaitingForResponseOutboundState} in order to wait for a
     * response.
     */
    public synchronized void processLockRequest() {
        if (log.isDebugEnabled())
            log.debug("Lock is requested while in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "Due to a lock request, the call will be disconnected (with a " +
                        "CANCEL or BYE) as soon as a SIP response has been received.");

        // Set call failed
        call.setStateFailed(FailedOutboundState.FailedSubState.WAITING_FOR_RESPONSE);

        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.OUTBOUND, "Call rejected due to lock request.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();
    }

    /**
     * Disconnects the active call.
     * <p>
     * Since a provisional response has not yet been received for the initial
     * outbound INVITE, a CANCEL request cannot be sent. The call is not
     * disconnected
     * until a provisional or final response is received. If a provisional
     * response is received, a CANCEL request is sent. If a final response is
     * received, a BYE request is sent after the call has been acknowledged.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedWaitingForResponseOutboundState} in order to wait for a
     * response.
     *
     * @param disconnectEvent carries the information regarding the disconnect.
     */
    public synchronized void disconnect(DisconnectEvent disconnectEvent) {
        if (log.isDebugEnabled())
            log.debug("Disconnect is requested while in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "The service is disconnecting the call. The call will be " +
                        "disconnected (with a CANCEL or BYE) as soon as a " +
                        "SIP response has been received.");

        // Set call failed
        call.setStateFailed(FailedOutboundState.FailedSubState.WAITING_FOR_RESPONSE);

        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.OUTBOUND, "Call disconnected by near end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        null, null)));

        // This is because EE expects one event per called method, but it
        // does not conform with the CCXML standard
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.NEAR_END, true));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();
    }

    /**
     * Handles a Call timeout.
     * <p>
     * If it was the {@link CallTimerTask.Type.CALL_NOT_CONNECTED} timer that
     * expired, a {@link FailedEvent} is generated and the state is set to
     * {@link FailedWaitingForResponseOutboundState}.
     * Other timers should not expire in this state, and are ignored.
     * @param callTimeoutEvent carries information regarding the call timeout.
     */
    public synchronized void handleCallTimeout(CallTimeoutEvent callTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("A call timeout <" + callTimeoutEvent.getType() +
                    "> was received in " + this + ".");

        if (callTimeoutEvent.getType() == CallTimerTask.Type.CALL_NOT_CONNECTED) {

            int responseCode = Response.REQUEST_TIMEOUT;
            String message = "The \"max duration before connected\" timer has " +
                             "expired, i.e. the call was not connected in time." +
                             "It is handled as if a SIP " + responseCode +
                             " response was received. The call will be disconnected " +
                             "(with a CANCEL or BYE) as soon as a SIP response has been " +
                             "received";
            if (log.isInfoEnabled()) log.info(message);

            call.setStateFailed(FailedOutboundState.FailedSubState.WAITING_FOR_RESPONSE);

            FailedEvent failedEvent = new FailedEvent(
                    call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                    CallDirection.OUTBOUND,
                    message,
                    call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(
                        responseCode, null));
            call.fireEvent(failedEvent);

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

        } else {
            if (log.isDebugEnabled())
                log.debug("The call timeout <" + callTimeoutEvent.getType() +
                        "> is ignored.");
        }
    }


    //===================== Private Methods =======================

    /**
     * Processes a 1xx response received for an outbound INVITE.
     * <p>
     * The response is treated as described below.
     * <p>
     * <ul>
     * <li>"Trying" response:<br> Is debug logged. The state is set to
     * {@link ProgressingProceedingOutboundState}.
     * </li>
     * <li>"Call Is Being Forwarded" response:<br> Is debug logged. The state
     * is set to {@link ProgressingProceedingOutboundState}.
     * </li>
     * <li>"Queued" response:<br> Is debug logged. The state is set to
     * {@link ProgressingProceedingOutboundState}.
     * </li>
     * <li>"Ringing" response:<br>
     * A {@link com.mobeon.masp.callmanager.events.ProgressingEvent} is
     * generated indicating no early media.
     * The state is set to {@link ProgressingProceedingOutboundState}.
     * </li>
     * <li>"Session Progress" response and all other 1xx responses:<br>
     * Is handled using {@link #processSessionProgressResponse(SipResponseEvent)}.
     * </li>
     * </ul>
     * <p>
     * Finally, if the response is not a 100 Trying and was sent reliably, an
     * empty SIP PRACK request is generated for the response.
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process1xxResponseToInvite(SipResponseEvent sipResponseEvent) {

    	((com.mobeon.masp.callmanager.callhandling.CallImpl) call).exitSipInviteRingAckKpiCheckpoint(); // KPI
    	
        // Check if response is from a forked dialog and update call with new dialog
        handleForkedSipDialog(sipResponseEvent, false);

        int responseCode = sipResponseEvent.getResponseCode();

        try {
            if ((responseCode == Response.TRYING) ||
                    (responseCode == Response.CALL_IS_BEING_FORWARDED) ||
                    (responseCode == Response.QUEUED)) {

                // Trying, Call Is Being Forwarded and Queued is only logged.
                if (log.isInfoEnabled()) log.info(
                        "No special action is taken for the SIP " + responseCode +
                                " response.");

                call.setStateProgressing(ProgressingSubState.PROCEEDING);

            } else if (responseCode == Response.RINGING) {
                call.setStateProgressing(ProgressingSubState.PROCEEDING);

                sipResponseEvent.getTransaction().getDialog();
                //sipResponseEvent.getEstablishedDialogId();

                ProgressingEvent progressingEvent = new ProgressingEvent(call, false);
                call.fireEvent(progressingEvent);
                if (log.isInfoEnabled()) log.info("The call is ringing.");

            } else {
                // All other SIP 1xx responses should be handled as a
                // Session Progress response
                if (log.isDebugEnabled())
                    log.debug("A session progress has been received.");

                processSessionProgressResponse(sipResponseEvent);
            }

            if ((responseCode != Response.TRYING) &&
                    (call.isProvisionalResponseReliable(sipResponseEvent))) {

                // Send PRACK request
                sendPrackRequest(sipResponseEvent);

                if (log.isInfoEnabled()) log.info(
                        "PRACK is sent to acknowledge the reliable SIP " +
                                responseCode + " response.");
            }

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Processing provisional response resulted in " +
                        "call disconnected.");
        }
    }

    /**
     * Processes a 2xx response received for an outbound INVITE.
     * <p>
     * The response is treated as described below:
     * <ul>
     * <li>
     * A SIP ACK request is sent using {@link #sendAckRequest()}.
     * </li>
     * <li>
     * The SDP Answer (if any) is retrieved, parsed and stored in the call
     * using {@link #retrieveAndStoreSdpAnswer(SipResponseEvent)}.
     * </li>
     * <li>
     * A check is made to verify that the SDP Answer was stored ok in the call
     * using {@link #assertSdpAnswerExists()}.
     * </li>
     * <li>
     * An SDP intersection between the SDP offer in the initial INVITE and the
     * SDP answer is located using {@link #retrieveSdpIntersection(int)}.
     * </li>
     * <li>
     * An outbound media stream is created using
     * {@link #createOutboundStream(int, SdpIntersection)}.
     * </li>
     * <li>
     * A {@link ConnectedEvent} is generated and the state is set to
     * {@link ConnectedOutboundState}.
     * </li>
     * </ul>
     *
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process2xxResponseToInvite(SipResponseEvent sipResponseEvent) {

    	((com.mobeon.masp.callmanager.callhandling.CallImpl) call).exitSipInviteRingAckKpiCheckpoint(); // KPI
    	
        // Check if response is from a forked dialog and update call with new dialog
        handleForkedSipDialog(sipResponseEvent, false);

        if (log.isInfoEnabled()) log.info(
                "A SIP final ok response is received for INVITE. " +
                        "An ACK will be sent and media negotiation is performed.");
        try {
            // Send ACK request
            sendAckRequest();

            if (log.isDebugEnabled())
                log.debug("SIP ACK is sent.");

            // Retrieve and store the SDP answer
            retrieveAndStoreSdpAnswer(sipResponseEvent);

            if (log.isDebugEnabled())
                log.debug("SDP answer is parsed.");

            // Verify that an SDP answer was included
            assertSdpAnswerExists();

            // Retrieve the SDP intersection
            SdpIntersection sdpIntersection =
                    retrieveSdpIntersection(sipResponseEvent.getResponseCode());
            if (log.isDebugEnabled())
                log.debug("SDP answer matches outbound media types.");
                
            //handle re-negotiated SDP on Inbound Stream
            if (log.isDebugEnabled())
                log.debug("reNegotiatedSdpOnInboundStream");
            call.reNegotiatedSdpOnInboundStream(sdpIntersection);
                
            addFarEndConnection(sipResponseEvent);

            // Create the outbound stream.
            createOutboundStream(sipResponseEvent.getResponseCode(), sdpIntersection);

            if (log.isDebugEnabled())
                log.debug("Outbound stream is created.");

            // The call is considered connected.
            call.setStateConnected();
            call.fireEvent(new ConnectedEvent(call));

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Processing 2xx response resulted in call disconnected.");
        } catch (SdpInternalErrorException e) {
            String message =
                    "Processing 2xx response resulted in call disconnected.";
            if (log.isDebugEnabled())
                log.debug(message, e);
        }
    }

    /**
     * Processes a 3xx response received for an outbound INVITE.
     * <p>
     * The response is treated as described below:
     * <ul>
     * <li>
     * A check is made to verify that a call redirection is allowed to be
     * handled. This is done using
     * {@link #assertCallRedirectionAllowed(SipResponseEvent)}.
     * </li>
     * <li>
     * The redirection contacts are retrieved from the response and stored in
     * the call using
     * {@link OutboundCallInternal#retrieveContacts(SipResponseEvent)}.
     * </li>
     * <li>
     * The next contact URI to try is retrieved using
     * {@link #getNextContact(SipResponseEvent)}.
     * </li>
     * <li>
     * A redirected INVITE request is sent using
     * {@link #sendRedirectedInvite(SipURI)}.
     * </li>
     * <li>
     * The state is set to {@link ProgressingCallingOutboundState}.
     * </li>
     * </ul>
     *
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process3xxResponseToInvite(SipResponseEvent sipResponseEvent) {
        
    	((com.mobeon.masp.callmanager.callhandling.CallImpl) call).exitSipInviteRingAckKpiCheckpoint(); // KPI
    	
    	try {
            // Check if response is from a forked dialog and update call with new dialog
            handleForkedSipDialog(sipResponseEvent, false);

            // Verify that call redirection is allowed.
            assertCallRedirectionAllowed(sipResponseEvent);

            if (log.isDebugEnabled())
                log.debug("First level of redirection.");

            if (log.isInfoEnabled()) log.info(
                    "The call has been redirected to another contact. " +
                            "A redirected INVITE will be sent.");

            // TODO: Phase 2! Handle expires in Contact header?

            // Retrieve contacts from the 3xx response.
            call.retrieveContacts(sipResponseEvent);

            // Get the contact URI to try this time
            SipURI contactUri = getNextContact(sipResponseEvent);

            if (log.isDebugEnabled())
                log.debug("The next URI to try: " + contactUri);

            // Sent the redirected INVITE request
            sendRedirectedInvite(contactUri);

            if (log.isDebugEnabled())
                log.debug("A redirected SIP INVITE request is sent.");

            call.setStateProgressing(ProgressingSubState.CALLING);

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Processing 3xx response resulted in call disconnected.");
        }
    }

    /**
     * Processes a 5xx response received for an outbound INVITE.
     * <p>
     * The response is treated as described below:
     * <ul>
     * <li>
     * If the INVITE has been previously redirected, the next contact URI to
     * try is retrieved using {@link #getNextContact(SipResponseEvent)} and a
     * redirected INVITE request is sent using
     * {@link #sendRedirectedInvite(SipURI)}.
     * The state is set to {@link ProgressingCallingOutboundState}.
     * </li>
     * <li>
     * Otherwise, the call is rejected using
     * {@link #callRejected(Integer, Q850CauseLocationPair)}
     * </li>
     * </ul>
     *
     * @param sipResponseEvent carries the SIP response.
     */
    protected void process5xxResponseToInvite(SipResponseEvent sipResponseEvent) {
    	
    	((com.mobeon.masp.callmanager.callhandling.CallImpl) call).exitSipInviteRingAckKpiCheckpoint(); // KPI
    	
    	try {
            // TODO: Phase 2! Handle expires in Contact header?

            // Check if response is from a forked dialog and update call with new dialog
            handleForkedSipDialog(sipResponseEvent, false);

            if (call.isRedirected()) {
                // Get the contact URI to try this time
                SipURI contactUri = getNextContact(sipResponseEvent);

                if (log.isDebugEnabled())
                    log.debug("The next URI to try: " + contactUri);

                // Sent the redirected INVITE request
                sendRedirectedInvite(contactUri);
                if (log.isDebugEnabled())
                    log.debug("A redirected SIP INVITE request is sent.");

                if (log.isInfoEnabled()) log.info(
                        "A SIP 5xx response is received for a redirected INVITE. " +
                                "A new contact is tried and a new INVITE is sent.");

                call.setStateProgressing(ProgressingSubState.CALLING);
            } else {
                callRejected(
                        sipResponseEvent.getResponseCode(),
                        sipResponseEvent.getSipMessage().getQ850CauseLocation());
            }

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled())
                log.debug("Processing 5xx response resulted in call disconnected.");
        }
    }


}
