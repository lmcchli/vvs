/*
 * Copyright (c) 2005 Mobeon AB. All Rights Reserved.
 */
package com.mobeon.masp.callmanager.callhandling.states.outbound;

import com.mobeon.masp.callmanager.callhandling.OutboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.callhandling.CallToCall;
import com.mobeon.masp.callmanager.events.DisconnectedEvent;
import com.mobeon.masp.callmanager.sip.message.SipRequest;
import com.mobeon.masp.callmanager.sip.message.SipRequestFactory;
import com.mobeon.masp.callmanager.callhandling.events.DisconnectEvent;
import com.mobeon.masp.callmanager.callhandling.events.SendTokenEvent;
import com.mobeon.masp.callmanager.sip.events.SipRequestEvent;
import com.mobeon.masp.callmanager.sip.events.SipResponseEvent;
import com.mobeon.masp.callmanager.sip.events.SipTimeoutEvent;
import com.mobeon.masp.callmanager.sip.header.SipWarning;
import com.mobeon.masp.callmanager.events.ErrorEvent;
import com.mobeon.masp.callmanager.sdp.SdpInternalErrorException;
import com.mobeon.masp.callmanager.sdp.SdpIntersection;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.callhandling.events.PlayEvent;
import com.mobeon.masp.callmanager.callhandling.events.RecordEvent;
import com.mobeon.masp.callmanager.callhandling.events.StopPlayEvent;
import com.mobeon.masp.callmanager.callhandling.events.StopRecordEvent;
import com.mobeon.masp.callmanager.callhandling.states.outbound.DisconnectedOutboundState.DisconnectedSubState;
import com.mobeon.masp.callmanager.CMUtils;
import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.videofastupdate.MediaControlImpl;
import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;
import com.mobeon.masp.stream.IOutboundMediaStream;
import com.mobeon.masp.stream.IInboundMediaStream;

import javax.sip.message.Request;
import javax.sip.message.Response;

/**
 * Represents the outbound state Connected.
 * <p>
 * The Connected state is entered when the initial call setup INVITE has been
 * accepted by the callee and it has been acknowledged by the caller.
 * In Connected state, the caller can disconnect the call, send tokens and play
 * or record media.
 * <p>
 * All methods are synchronized to handle each event atomically.
 *
 * @author Malin Flodin
 */
public class ConnectedOutboundState extends OutboundCallState {

    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public ConnectedOutboundState(OutboundCallInternal call) {
        super(call);
    }

    public String toString() {
        return "Connected state";
    }

    /**
     * Handles an administrators lock request.
     * <p>
     * A SIP BYE request is sent.
     * A {@link DisconnectedEvent} is generated and the state is set to
     * {@link DisconnectedLingeringByeOutboundState}.
     * <br>
     * If the BYE request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorCompletedOutboundState}.
     */
    public synchronized void processLockRequest() {
        if (log.isDebugEnabled())
            log.debug("Lock requested in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "Due to a lock request, the call is disconnected with a " +
                        "SIP BYE request.");

        // Set the state to disconnected before a disconnected event is sent
        // This is done to make sure that clean up such as stream delete has
        // been performed before the event is fired.
        call.setStateDisconnected(DisconnectedSubState.LINGERING_BYE);
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.NEAR_END, false));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send BYE request
        sendByeRequest();
    }

    /**
     * Handles a request to play media.
     * The media is played on the outbound stream of the call using
     * {@link OutboundCallInternal#playOnOutboundStream(PlayEvent)}.
     * @param playEvent carries information regarding the play request.
     */
    public synchronized void play(PlayEvent playEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to play media was received in " + this + ".");
        call.playOnOutboundStream(playEvent);
    }

    /**
     * Handles a request to record media.
     * Media is recorded from the inbound stream of the call using
     * {@link OutboundCallInternal#recordOnInboundStream(RecordEvent)}.
     * @param recordEvent carries information regarding the record request.
     */
    public synchronized void record(RecordEvent recordEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to record media was received in " + this + ".");
        call.recordOnInboundStream(recordEvent);
    }

    /**
     * Handles a request to stop an ogoing play.
     * The ongoing play (if any) is stopped using
     * {@link OutboundCallInternal#stopOngoingPlay(StopPlayEvent)}.
     * @param stopPlayEvent
     */
    public synchronized void stopPlay(StopPlayEvent stopPlayEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to stop an ongoing play was received in " +
                    this + ".");
        call.stopOngoingPlay(stopPlayEvent);
    }

    /**
     * Handles a request to stop an ongoing recording.
     * The ongoing recording (if any) is stopped using
     * {@link OutboundCallInternal#stopOngoingRecord(StopRecordEvent)}.
     * @param stopRecordEvent
     */
    public synchronized void stopRecord(StopRecordEvent stopRecordEvent) {
        if (log.isDebugEnabled())
            log.debug("Request to stop an ongoing record was received in " +
                    this + ".");
        call.stopOngoingRecord(stopRecordEvent);
    }

    /**
     * Handles a request to send a Video Fast Update request.
     * The Video Fast Update request is sent using the SIP INFO method.
     * <p>
     * A SIP INFO request is sent including a Picture Fast Update request.
     * If the SIP INFO request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorCompletedOutboundState}.
     */
    public synchronized void processVideoFastUpdateRequest() {
        IOutboundMediaStream os = call.getOutboundStream();
        if (os.usesRTCPPictureFastUpdate()) {
            if (log.isDebugEnabled())
                log.debug("Request to send a Video Fast Update request over RTCP " +
                          "received in " + this + ".");

            IInboundMediaStream is = call.getInboundStream();
            int ssrc = is.getSenderSSRC();
            if (log.isDebugEnabled())
                log.debug("Inbound stream sender SSRC = " + ssrc);

            os.sendPictureFastUpdate(ssrc);
        }
        else {
            if (log.isDebugEnabled())
                log.debug("Request to send a Video Fast Update request over SIP INFO " +
                          "received in " + this + ".");

            if (log.isInfoEnabled()) log.info(
                    "Request to send a Video Fast Update is received. " +
                            "A SIP INFO request will be sent.");
            try {
                SipRequest sipRequest =
                        CMUtils.getInstance().getSipRequestFactory().
                                createInfoRequest(
                                        call.getDialog(),
                                        SipRequestFactory.InfoType.VIDEO_FAST_UPDATE,
                                        MediaControlImpl.getInstance().
                                                createPictureFastUpdateRequest(),
                                        call.getPChargingVector());
                CMUtils.getInstance().getSipMessageSender().sendRequestWithinDialog(
                        call.getDialog(), sipRequest);
    
            } catch (Exception e) {
                call.errorOccurred(
                        "Could not send SIP INFO request: " + e.getMessage(), false);
            }
        }
    }

    /**
     * This method is used when the Call Manager client disconnects the call.
     * <p>
     * A {@link DisconnectedEvent} is generated,
     * the state is set to {@link DisconnectedLingeringByeOutboundState}
     * and a SIP BYE request is sent.
     * <p>
     * If the SIP BYE request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorCompletedOutboundState}.
     *
     * @param disconnectEvent carries the information regarding the disconnect.
     */
    public synchronized void disconnect(DisconnectEvent disconnectEvent) {
        if (log.isDebugEnabled())
            log.debug("Disconnect received in " + this +
                    ". The call is disconnected.");

        if (log.isInfoEnabled()) log.info(
                "The service is disconnecting the call. Call is disconnected" +
                        " with a SIP BYE request.");

        // Set the state to disconnected before a disconnected event is sent
        // This is done to make sure that clean up such as stream delete has
        // been performed before the event is fired.
        call.setStateDisconnected(DisconnectedSubState.LINGERING_BYE);
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.NEAR_END, false));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        sendByeRequest();
    }

    /**
     * This methods is used when the Call Manager client wants to send tokens
     * on the outbound media stream.
     * <p>
     * The tokens are sent using
     * {@link OutboundCallInternal#sendTokens(com.mobeon.masp.stream.ControlToken[])}.
     * @param sendTokenEvent
     */
    public synchronized void sendToken(SendTokenEvent sendTokenEvent) {
        if (log.isDebugEnabled())
            log.debug("SendToken received in " + this + ".");
        call.sendTokens(sendTokenEvent.getTokens());
    }

    /**
     * Handles a SIP ACK request.
     * <p>
     * The
     * {@link com.mobeon.masp.callmanager.callhandling.CallTimerTask.Type.NO_ACK}
     * timer is canceled and the ACK is otherwise ignored.
     * @param sipRequestEvent carries the SIP ACK request.
     */
    public synchronized void processAck(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP ACK request was received in " + this + ".");

        call.cancelNoAckTimer();

        if (log.isInfoEnabled())
            log.info("SIP ACK request is received and ignored.");
    }

    /**
     * Handles a SIP BYE request.
     * <p>
     * A {@link DisconnectedEvent} is generated and the state is set to
     * {@link DisconnectedCompletedOutboundState}.
     * A SIP OK response is sent for the BYE request.
     * <p>
     * If the SIP OK response could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorCompletedOutboundState}.
     * @param sipRequestEvent carries the SIP BYE request.
     */
    public synchronized void processBye(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP BYE request received in " + this + ".");

        if (log.isInfoEnabled()) log.info(
                "The far end has disconnected the call with a SIP BYE request.");

        // Set the state to disconnected before a disconnected event is sent
        // This is done to make sure that clean up such as stream delete has
        // been performed before the event is fired.
        call.setStateDisconnected(DisconnectedSubState.COMPLETED);
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.FAR_END, false));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        call.sendOkResponse(sipRequestEvent, true);
    }


    /**
     * Handles a SIP re-INVITE request.
     * <p>
     * Re-negotiations where the remote SDP is identical to the previously
     * received remote SDP are allowed.
     * In addition, if the remote SDP is different but contains AT LEAST
     * the previously negotiated codec, we also allow re-negotiation and
     * include an SDP containing the codecs we accept (and require/impose)
     * in the 200 OK response.
     * <p>
     * If the PRACK request contains a new SDP offer, the offer is parsed and
     * examined using
     * {@link #retrieveAndStoreRemoteSdpAfterConnect(SipRequestEvent)}.
     * <p>
     * If the re-negotiation is acceptable, a SIP "OK" response is sent for the
     * re-INVITE.
     * <p>
     * If the re-INVITE contained no SDP offer, it is rejected with a SIP
     * 488 "Not Acceptable Here" response.
     * <p>
     * If the response to the re-INVITE could not be sent, an
     * {@link ErrorEvent} is generated and the state is set to
     * completed error state.
     *
     * @param sipRequestEvent carries the SIP re-INVITE request.
     */
    public synchronized void processReInvite(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP re-INVITE request received in " + this + ".");

        try {
            if (call.containsSdp(sipRequestEvent)) {
                if (log.isDebugEnabled())
                    log.debug("A new remote SDP offer is received.");

                // Retrieve, store and validate the remote SDP offer
                retrieveStoreAndOnlyVerifyMinimalRemoteSdpAfterConnect(sipRequestEvent);
                if (log.isDebugEnabled())
                    log.debug("Remote SDP offer from re-invite is parsed, stored and minmal basic parameters are validated.");

                // Basic parameters of new SDP offer validated; verify this new SDP contains
                // the necessary required codecs for us to accept this re-invite request
                SdpIntersection sdpIntersection = null;
                try {
                	sdpIntersection = call.findSdpIntersection(call.getConfiguredOutboundCallMediaTypes(), false);
                } catch (SdpInternalErrorException e) {
                	log.error("processReInvite: unable to find Intersection in proposed SDP", e);
                }
                
                if (sdpIntersection == null) {
                    if (log.isInfoEnabled()) log.info(
                            "SIP re-INVITE is rejected with a SIP " +
                                    "488 \"Not Acceptable Here\" response.");

                    // Send NotAcceptableHere response
                    call.sendNotAcceptableHereResponse(
                            sipRequestEvent, SipWarning.RENEGOTIATION_NOT_SUPPORTED);
                } else {
                	// We found in intersection in the SDP proposed in the Re-Invite;
                	// we will accept the request, specifying (again) the codecs we select
                	// by retrieving the SDP we initially offered and including it in the
                	// 200 OK response.
                    
                    //String sdpAnswer = call.getLocalSdpAnswer();
                    
                    // Since we initiated the call, we need to send the original SDP we offered
                    String sdpAnswer = call.getLocalSdpOffer();

                    if (log.isDebugEnabled()) log.debug(
                            "SDP answer is included in Ok response for re-INVITE: " +
                                    sdpAnswer);

                    if (log.isInfoEnabled()) log.info(
                            "SIP re-INVITE is accepted with a SIP 200 \"OK\" response.");

                    // Send a SIP "Ok" response to re-INVITE
                    sendOkResponse(sipRequestEvent, sdpAnswer);

                    call.startNoAckTimer();
                }
            } else {
                if (log.isInfoEnabled()) log.info(
                        "SIP re-INVITE is rejected with a SIP " +
                                "488 \"Not Acceptable Here\" response.");

                // Send NotAcceptableHere response
                call.sendNotAcceptableHereResponse(
                        sipRequestEvent, SipWarning.RENEGOTIATION_NOT_SUPPORTED);
            }

        } catch (IllegalStateException e) {
            if (log.isDebugEnabled()) log.debug("Re-INVITE handling failed.");
        }
    }

    /**
     * Handles a SIP OPTIONS request.
     * <p>
     * A SIP OK response is generated. If an error
     * occurs when sending the OK response, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorCompletedOutboundState}.
     * @param sipRequestEvent
     */
    public synchronized void processOptions(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP OPTIONS request received in " + this + ".");
        if (log.isInfoEnabled()) log.info("SIP OPTIONS request is answered.");
        call.sendOkResponse(sipRequestEvent, false);
    }

    /**
     * If the call is joined, SIP INFO messages are forwarded to the other call
     * in this state.
     *
     * @param sipRequestEvent
     */
    public synchronized void processInfo(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled()) {
            log.debug("SIP INFO request received in " + this + ".");
        }

        if (log.isInfoEnabled()) {
            log.info("SIP INFO request is forwarded to the Inbound Call.");
        }

        CallToCall otherCall = call.getJoinedToCall();
        if (call.isCallJoined() && (otherCall != null) &&
                call.containsMediaControl(sipRequestEvent)) {
            String tag = otherCall.forwardVFURequest(sipRequestEvent);
            if (tag != null) {
                call.addPendingRequest(tag, sipRequestEvent);
            }
        } else {
            if (log.isInfoEnabled()) {
                log.info("SIP INFO request is rejected since it is not " +
                        "supported in current state.");
            }

            call.sendMethodNotAllowedResponse(sipRequestEvent);
        }
    }

    /**
     * Parses a SIP response. In this state, only responses to INFO or PRACK
     * requests are expected. If the INFO/PRACK request is responded with
     * either SIP Request Timeout or SIP Call/Transaction Does Not Exist, the
     * call is disconnected, i.e. a BYE request is sent,
     * a {@link DisconnectedEvent} is generated and the state is set to
     * {@link DisconnectedLingeringByeOutboundState}.
     * <p>
     * Otherwise for an INFO response, if the call is joined the response is
     * forwarded to the joined call. Else, the response is handled using
     * {@link #processInfoResponse(SipResponseEvent)}.
     * @param sipResponseEvent carries the SIP response.
     */
    public synchronized void processSipResponse(SipResponseEvent sipResponseEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP " + sipResponseEvent.getResponseCode() +
                    " response received for a " + sipResponseEvent.getMethod() +
                    " request in " + this + ".");

        String method = Request.INFO;
        Integer responseCode =
                sipResponseEvent.retrieveResponseCodeForMethod(Request.INFO);
        if (responseCode == null) {
            responseCode =
                    sipResponseEvent.retrieveResponseCodeForMethod(Request.PRACK);
            method = Request.PRACK;
        }

        if (responseCode != null) {
            if (log.isDebugEnabled())
                log.debug("Processing " + method + " response.");

            if ((responseCode == Response.CALL_OR_TRANSACTION_DOES_NOT_EXIST) ||
                    (responseCode == Response.REQUEST_TIMEOUT)) {
                if (log.isInfoEnabled())
                    log.info("SIP " + responseCode + " response to a " +
                            method + " request. " +
                            "The call will be disconnected with a SIP BYE request.");
                // Set the state to disconnected before a disconnected event is sent
                // This is done to make sure that clean up such as stream delete has
                // been performed before the event is fired.
                call.setStateDisconnected(DisconnectedSubState.LINGERING_BYE);
                call.fireEvent(new DisconnectedEvent(
                        call, DisconnectedEvent.Reason.NEAR_END, false));

                // Make sure the streams are deleted after the event is sent.
                // This is done to make sure that the event is generated before any
                // event generated by stream.
                call.deleteStreams();

                sendByeRequest();
            } else {
                if (method.equals(Request.INFO)) {
                    CallToCall otherCall = call.getJoinedToCall();
                    if (call.isCallJoined() && (otherCall != null)) {
                        otherCall.forwardVFUResponse(sipResponseEvent);
                    } else {
                        processInfoResponse(sipResponseEvent);
                    }
                }
            }
        }
    }

    /**
     * Handles a SIP timeout event.
     * <p>
     * If a timeout occurred for an INVITE, this must be an ACK that
     * never arrived for a received re-INVITE request.
     * A timeout for an INVITE or a PRACK request results in a SIP BYE request
     * sent, an {@link ErrorEvent} generated and the state set to
     * {@link ErrorLingeringByeOutboundState}.
     * <p>
     * Otherwise, an {@link ErrorEvent} is generated and the state is set to
     * {@link ErrorOutboundState}.
     *
     * @param sipTimeoutEvent carries information regarding the timeout event.
     */
    public synchronized void processSipTimeout(SipTimeoutEvent sipTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP timeout expired in " + this + ".");

        // If a timeout occurred for an INVITE, this must be an ACK that
        // never arrived for a received re-INVITE request.
        String method = sipTimeoutEvent.getMethod();
        if (method.equals(Request.INVITE) || method.equals(Request.PRACK)){
            if (log.isInfoEnabled())
                log.info("SIP timeout event received for SIP " + method + ". " +
                        "A SIP BYE request will be sent.");

            call.setStateError(ErrorOutboundState.ErrorSubState.LINGERING_BYE);
            call.fireEvent(new ErrorEvent(
                    call, CallDirection.OUTBOUND,
                    "SIP timeout occurred for SIP " + method + ". The call will " +
                            "be ended with a SIP BYE request.", false));
            call.deleteStreams();
            sendByeRequest();
        } else {
            call.errorOccurred(
                    "SIP timeout expired. The call is considered completed.",
                    false);
        }
    }

    /**
     * Handles a Call timeout.
     * <p>
     * If it was the {@link CallTimerTask.Type.MAX_CALL_DURATION} timer that
     * expired, a {@link DisconnectedEvent} is generated, the state is set to
     * {@link DisconnectedLingeringByeOutboundState} and a SIP BYE request is
     * sent. Other timers should no expire in this state, and are ignored.
     * <p>
     * If the call timeout is of type {@link CallTimerTask.Type.NO_ACK}, an
     * {@link ErrorEvent} is generated, the state is set to
     * {@link ErrorLingeringByeOutboundState} and a SIP BYE request is sent.
     * <p>
     * If the SIP BYE request could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorCompletedOutboundState}.
     *
     * @param callTimeoutEvent carries information regarding the call timeout.
     */
    public synchronized void handleCallTimeout(CallTimeoutEvent callTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("A call timeout <" + callTimeoutEvent.getType() +
                    "> was received in " + this + ".");

        if (callTimeoutEvent.getType() == CallTimerTask.Type.MAX_CALL_DURATION) {
            String message = "Max Call Duration timer expired. The call is " +
                             "disconnected with a SIP BYE request.";
            if (log.isInfoEnabled()) log.info(message);

            // Set the state to disconnected before a disconnected event is sent
            // This is done to make sure that clean up such as stream delete has
            // been performed before the event is fired.
            call.setStateDisconnected(DisconnectedSubState.LINGERING_BYE);
            call.fireEvent(new DisconnectedEvent(
                    call, DisconnectedEvent.Reason.NEAR_END, false));

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            // Send BYE request
            sendByeRequest();

        } else if (callTimeoutEvent.getType() == CallTimerTask.Type.NO_ACK) {
            String message = "The call has timed out while waiting " +
                    "for an ACK on a re-INVITE. The call will be ended " +
                    "with a SIP BYE request.";

            log.error(message + " CalledParty: " + call.getCalledParty().toString()
                    + " dialogId=" + call.getInitialDialogId());

            call.setStateError(ErrorOutboundState.ErrorSubState.LINGERING_BYE);
            call.fireEvent(new ErrorEvent(
                    call, CallDirection.OUTBOUND, message, false));

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            // Send BYE request
            sendByeRequest();

        } else {
            if (log.isDebugEnabled())
                log.debug("The call timeout <" + callTimeoutEvent.getType() +
                        "> is ignored.");
        }
    }

    /**
     * Handles the detection of an abandoned stream.
     * <p>
     * In this state this is interpreted as the call being abandoned by far end.
     * The call is disconnected, i.e. a {@link DisconnectedEvent} is generated,
     * the state is set to {@link DisconnectedLingeringByeOutboundState} and a
     * SIP BYE request is sent.
     */
    public synchronized void handleAbandonedStream() {
        if (log.isDebugEnabled())
            log.debug("A stream was detected abandoned in " + this +
                      ". The call is disconnected.");

        if (log.isInfoEnabled()) log.info(
                "A stream was detected abandoned. The call is disconnected " +
                        "with a SIP BYE request.");

        // Set the state to disconnected before a disconnected event is sent
        // This is done to make sure that clean up such as stream delete has
        // been performed before the event is fired.
        call.setStateDisconnected(DisconnectedSubState.LINGERING_BYE);
        call.fireEvent(new DisconnectedEvent(
                call, DisconnectedEvent.Reason.FAR_END_ABANDONED, false));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        sendByeRequest();
    }

}
