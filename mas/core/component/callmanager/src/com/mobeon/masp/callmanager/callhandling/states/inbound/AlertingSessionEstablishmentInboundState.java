/**
 * Copyright (c) Abcxyz
 * All Rights Reserved
 */
package com.mobeon.masp.callmanager.callhandling.states.inbound;

import com.mobeon.masp.callmanager.callhandling.InboundCallInternal;
import com.mobeon.masp.callmanager.callhandling.CallTimerTask;
import com.mobeon.masp.callmanager.callhandling.events.AcceptEvent;
import com.mobeon.masp.callmanager.callhandling.events.RejectEvent;
import com.mobeon.masp.callmanager.callhandling.events.CallTimeoutEvent;
import com.mobeon.masp.callmanager.events.EarlyMediaAvailableEvent;
import com.mobeon.masp.callmanager.events.ErrorEvent;
import com.mobeon.masp.callmanager.events.FailedEvent;
import com.mobeon.masp.callmanager.CallDirection;
import com.mobeon.masp.callmanager.sdp.SdpMediaDescription;
import com.mobeon.masp.callmanager.sdp.SdpSessionDescription;
import com.mobeon.masp.callmanager.sessionestablishment.PreconditionException;
import com.mobeon.masp.callmanager.sessionestablishment.UnicastException;
import com.mobeon.masp.callmanager.sip.SipConstants;
import com.mobeon.masp.callmanager.sip.events.SipRequestEvent;
import com.mobeon.masp.callmanager.sip.message.SipResponse;
import com.mobeon.common.cmnaccess.oam.CommonOamManager;
import com.mobeon.common.logging.ILogger;
import com.mobeon.common.logging.ILoggerFactory;

import javax.sip.message.Response;
import java.util.Iterator;
import java.util.List;
import java.util.Arrays;

/**
 * Represents the sub state "SessionEstablishment" of {@link AlertingInboundState}.
 * <p>
 * This sub state is entered when:
 * <ul>
 * <li> Call Manager has precondition and/or unicast validation enabled and
 * <li> either or both conditions have not being fulfilled yet and
 * <li> SIP Prack has being received from UAC from a previous Session Progress response and
 * <li> Call manager is now waiting for a SIP UPDATE to figure out if preconditions/unicast are fulfilled
 * </ul> 
 * <p>
 * This class is thread-safe.
 * All methods are synchronized to handle each event atomically.
 */
public class AlertingSessionEstablishmentInboundState extends AlertingInboundState {

    private final ILogger log = ILoggerFactory.getILogger(getClass());

    public AlertingSessionEstablishmentInboundState(InboundCallInternal call) {
        super(call);
    }

    public String toString() {
        return "Alerting state (sub state SessionEstablishment)";
    }

    /**
     * This method is used when the Call Manager client accepts the inbound call while 
     * Call Manager is waiting for an UPDATE request from UAC.
     * <ul>
     * <li>
     * Buffer the accept until the UPDATE request is received {@link #sendOkResponse(String)}.
     * </li>
     * <li>
     * Accept will be triggerd only if session establishment conditions are fulfilled
     * </li>
     * </ul>
     *
     * @param acceptEvent carries the information regarding the accept event.
     */
    public synchronized void accept(AcceptEvent acceptEvent) {
        if (log.isDebugEnabled())
            log.debug("Accept received in " + this + ".");

        if (log.isInfoEnabled())
            log.info("The service is accepting the call.");

        call.setAcceptReceivedInWaitForPrack(true);
    }

    /**
     * Handles an administrators lock request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * The initial inbound INVITE is rejected with a SIP
     * "Temporarily Unavailable" response.
     * <p>
     * If the SIP error response could not be sent, an {@link ErrorEvent} is
     * generated and the state is set to {@link ErrorInboundState}.
     */
    public synchronized void processLockRequest() {
        String message = "The Service is temporarily unavailable due to the current administrative state: Locked.";

        if (log.isDebugEnabled())
            log.debug("Lock requested in " + this + ". " + message);

        if (log.isInfoEnabled())
            log.info("Due to a lock request, the INVITE is rejected with SIP " + "503 response.");

        // Set call failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, message,
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        call.sendErrorResponse(Response.SERVICE_UNAVAILABLE, call.getInitialSipRequestEvent(), message);
    }

    /**
     * This method is used when the Call Manager client rejects the inbound
     * call.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "Forbidden" response is sent for the initial INVITE.
     * <p>
     * If the SIP response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param rejectEvent carries the information regarding the reject event.
     */
    public synchronized void reject(RejectEvent rejectEvent) {
        if (log.isDebugEnabled())
            log.debug("Reject received in " + this + ". " + rejectEvent.getMessage());

        if (log.isInfoEnabled())
            log.info("The service is rejecting the call. A SIP " + rejectEvent.getCode() + " response will be sent.");

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_NEAR_END,
                CallDirection.INBOUND, rejectEvent.getMessage(),
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        call.sendErrorResponse(rejectEvent.getCode(), call.getInitialSipRequestEvent(), rejectEvent.getMessage());
    }

    /**
     * Parses a SIP UPDATE request and performs certain actions depending on state.
     * <p>
     * SIP UPDATE requests are only supported when precondition and/or unicast is enabled,
     * otherwise they are rejected with a SIP 403 "Forbidden" response.
     * @param sipRequestEvent sipRequestEvent
     */
    public synchronized void processUpdate(SipRequestEvent sipRequestEvent) {
        boolean preconditionsFulfilled = true;
        boolean unicastFulfilled = true;
        String sdpAnswer = null;
        SdpSessionDescription remoteSdp = null;

        boolean preconditionRequired = sipRequestEvent.getSipMessage().isRequired(SipConstants.EXTENSION_PRECONDITION);
        boolean preconditionSupported = sipRequestEvent.getSipMessage().isSupported(SipConstants.EXTENSION_PRECONDITION);
        boolean _100reliableRequired = sipRequestEvent.getSipMessage().isRequired(SipConstants.EXTENSION_100REL);
        boolean _100reliableSupported = sipRequestEvent.getSipMessage().isSupported(SipConstants.EXTENSION_100REL);
        boolean _100reliable = _100reliableRequired || _100reliableSupported;

        if (log.isDebugEnabled())
            log.debug("SIP UPDATE received in " + this + ".");

        try {
            if (call.containsSdp(sipRequestEvent)) {
                if (log.isDebugEnabled())
                    log.debug("A new remote SDP offer received in UPDATE");

                // Retrieve and store the remote SDP offer (this will parse the preconditions and unicast as well)
                retrieveAndStoreRemoteSdpPriorToAccept(sipRequestEvent, true);
                if (log.isDebugEnabled())
                    log.debug("Remote SDP offer is parsed and accepted.");

                remoteSdp = call.getPendingRemoteSdp();
            } else {
                if (log.isDebugEnabled())
                    log.debug("No remote SDP offer received in UPDATE");
            }

            SdpMediaDescription smd = null;
            if (remoteSdp != null) {
                int index = call.getSdpIntersection().getAudioIndex();
                SdpMediaDescription intersectionMediaDescription = call.getSdpIntersection().getSessionDescription().getMediaDescription(index);
                smd = remoteSdp.getMedia(intersectionMediaDescription.getMedia());
            }

            // Preconditions validation
            if (call.getConfig().isPreconditionEnabled()) {
                preconditionsFulfilled = call.getPreconditionStatusTable().update(smd, preconditionRequired, preconditionSupported, _100reliable);
            }

            // Unicast validation
            if (call.getConfig().isUnicastEnabled()) {
                unicastFulfilled = call.getUnicastStatus().update(smd, _100reliable);
            }

            if (call.containsSdp(sipRequestEvent)) {
                // Generate SDP answer which will contain precondition/unicast attributes
                sdpAnswer = createSdpAnswerFromIntersection(retrieveSdpIntersection(), call.getInboundConnectionProperties());
            }

            // Create outbound stream, if not already created
            if (preconditionsFulfilled && call.getOutboundStream() == null) {
                call.createOutboundStream(call.getSdpIntersection());
            }

            // Send a SIP OK response to UPDATE
            sendOkResponse(sipRequestEvent, sdpAnswer);

            if (log.isDebugEnabled())
                log.debug("OK response is sent for UPDATE (" + (sdpAnswer == null ? "No ":"") + "SDP answer included)");

            // Reset flag stating if the response MUST contain a Require header with the 'precondition' option tag and 
            // the precondition status table in the SDP answer after sending the response
            call.getPreconditionStatusTable().resetPreconditionRequire();

            if (preconditionsFulfilled && unicastFulfilled) {
                if (call.isEarlyMediaRequested()) {
                    // Go to Alerting Early Media Negotiated state
                    call.setStateAlerting(AlertingSubState.EARLY_MEDIA);
                    call.fireEvent(new EarlyMediaAvailableEvent(call));

                    if (call.isAcceptReceivedInWaitForPrack()) {
                        call.accept();
                        call.setAcceptReceivedInWaitForPrack(false);
                    }
                } else {
                    // Send a SIP Ringing response
                    sendRingingResponse();

                    // Go to Alerting Accepting state
                    call.setStateAlerting(AlertingSubState.ACCEPTING);

                    // Build list of proprietary headers
                    List<String> extensionHeaderList = Arrays.asList(PROPRIETARY_HEADER_FOR_INITIAL_INVITE_200OK_RESPONSE);

                    // Since SIP 183 Session Progress was sent reliably (just processed a PRACK for it),
                    // Send a SIP OK response to INVITE without including an SDP
                    sendOkResponse(null, extensionHeaderList);

                    Object perf = null;
                    if (CommonOamManager.profilerAgent.isProfilerEnabled()) {
                        try {
                            perf = CommonOamManager.profilerAgent.enterCheckpoint("MAS.CM.In.Sip.Req.Invite.2.Accepted");
                        } finally {
                            CommonOamManager.profilerAgent.exitCheckpoint(perf);
                        }
                    }

                    if (log.isDebugEnabled())
                        log.debug("Ok response is sent for INVITE.");
                }
            } else {
                if (log.isDebugEnabled())
                    log.debug("Session establishment conditions not fulfilled (precondition: " + preconditionsFulfilled + ", unicast: " + unicastFulfilled + "), still pending");
            }

        } catch (PreconditionException pe) {
            if (log.isDebugEnabled())
                log.debug("Precondition attribute(s) caused Error response " + pe.getExceptionCause().getSipErrorCode() + " to be sent for UPDATE"  +
                          (pe.getAdditionalInfo() == null ? "":" with additional info: "+pe.getAdditionalInfo()));
            call.sendErrorResponse(pe.getExceptionCause().getSipErrorCode(), sipRequestEvent, pe.getAdditionalInfo());
        } catch (UnicastException ue) {
            if (log.isDebugEnabled())
                log.debug("Unicast attribute caused Error response " + ue.getUnicastExceptionCause().getSipErrorCode() + " to be sent for UPDATE"  +
                          (ue.getAdditionalInfo() == null ? "":" with additional info: "+ue.getAdditionalInfo()));
            call.sendErrorResponse(ue.getUnicastExceptionCause().getSipErrorCode(), sipRequestEvent, ue.getAdditionalInfo());
        } catch (IllegalStateException ise) {
            // Methods that thrown IllegalStateException already sends back an error to UAc and deleted streams.
            log.debug("IllegalStateException: " + ise.getMessage(), ise);
        } catch (Exception e) {
            log.debug("Exception: " + e.getMessage(), e);
            handleError(Response.SERVER_INTERNAL_ERROR, null, sipRequestEvent);
        }
    }

    /**
     * Handles a SIP BYE request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "Request Terminated" response is sent for the pending INVITE request.
     * A SIP "OK" is sent as response to the BYE request.
     * <p>
     * If a SIP response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param sipRequestEvent carries the SIP BYE request.
     */
    public synchronized void processBye(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP BYE request received in " + this + ".");

        if (log.isInfoEnabled())
            log.info("The far end has disconnected the call with a SIP BYE request.");

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                CallDirection.INBOUND, "Call disconnected early by far end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(null, sipRequestEvent.getSipMessage().getQ850CauseLocation())));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Request Terminated response to initial INVITE
        call.sendErrorResponse(Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(), "Call terminated due to a BYE request.");

        // Send OK response to BYE request
        call.sendOkResponse(sipRequestEvent, true);
    }

    /**
     * Handles a SIP CANCEL request.
     * <p>
     * A {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * A SIP "Request Terminated" response is sent for the pending INVITE request.
     * A SIP "OK" is sent as response to the CANCEL request.
     * <p>
     * If a SIP response could not be sent, an {@link ErrorEvent} is generated
     * and the state is set to {@link ErrorInboundState}.
     *
     * @param sipRequestEvent carries the SIP CANCEL request.
     */
    public synchronized void processCancel(SipRequestEvent sipRequestEvent) {
        if (log.isDebugEnabled())
            log.debug("SIP CANCEL received in " + this + ".");

        if (log.isInfoEnabled())
            log.info("The far end has canceled the call with a SIP CANCEL request.");

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                CallDirection.INBOUND, "Call disconnected early by far end.",
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(null, sipRequestEvent.getSipMessage().getQ850CauseLocation())));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        // Send Request Terminated response to initial INVITE
        call.sendErrorResponse(Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(), "Call terminated due to a CANCEL request.");

        // Send OK response to CANCEL request
        call.sendOkResponse(sipRequestEvent, true);
    }

    /**
     * Handles a Call timeout.
     * <p>
     * If it was the {@link CallTimerTask.Type.CALL_NOT_ACCEPTED} timer that
     * expired, a {@link FailedEvent} is generated and the state is set to
     * {@link FailedCompletedInboundState}.
     * 
     * If it was the {@link CallTimerTask.Type.SESSION_PROGRESS_RETRANSMISSION} timer that
     * expired, a SIP 183 Session Progress is sent. No state change occurs. 
     * 
     * Other timers should no expire in this state, and are ignored.
     * @param callTimeoutEvent carries information regarding the call timeout.
     */
    public synchronized void handleCallTimeout(CallTimeoutEvent callTimeoutEvent) {
        if (log.isDebugEnabled())
            log.debug("A call timeout " + callTimeoutEvent.getType() + " was received in " + this + ".");

        int nsc = call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(null, null);

        if (callTimeoutEvent.getType() == CallTimerTask.Type.CALL_NOT_ACCEPTED) {
            String message = "The inbound call was not accepted by the service " +
                    "in time. It is considered abandoned and a SIP 408 " +
                    "response will be sent.";
            if (log.isInfoEnabled())
                log.info(message);

            // Set call to failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
            call.fireEvent(new FailedEvent(call, FailedEvent.Reason.NEAR_END_ABANDONED, CallDirection.INBOUND, message, nsc));

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            call.sendErrorResponse(Response.REQUEST_TIMEOUT, call.getInitialSipRequestEvent(), "Call was not accepted in time.");

        } else if (callTimeoutEvent.getType() == CallTimerTask.Type.EXPIRES) {
            String message = "The expires timer expired for the INVITE. A SIP 487 response will be sent.";
            if (log.isInfoEnabled())
                log.info(message);

            // Set call to failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
            call.fireEvent(new FailedEvent(call, FailedEvent.Reason.REJECTED_BY_NEAR_END, CallDirection.INBOUND, message, nsc));

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            call.sendErrorResponse(Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(), "Expires timer expired.");

        } else if (callTimeoutEvent.getType() == CallTimerTask.Type.SESSION_ESTABLISHMENT) {
            String message = "The inbound call was not accepted by the service in time. It is considered abandoned and a SIP 408 response will be sent.";
            if (log.isInfoEnabled())
                log.info(message);

            // Set call to failed
            call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
            call.fireEvent(new FailedEvent(call, FailedEvent.Reason.NEAR_END_ABANDONED, CallDirection.INBOUND, message, nsc));

            // Make sure the streams are deleted after the event is sent.
            // This is done to make sure that the event is generated before any
            // event generated by stream.
            call.deleteStreams();

            call.sendErrorResponse(Response.REQUEST_TIMEOUT, call.getInitialSipRequestEvent(), "Call was not accepted in time.");

        } else {
            if (log.isDebugEnabled())
                log.debug("The call timeout " + callTimeoutEvent.getType() + " is ignored.");
        }
    }

    /**
     * Handles the detection of an abandoned stream.
     * <p>
     * In this state this is interpreted as the call being abandoned by far end.
     * The call is disconnected, i.e. a {@link FailedEvent} is generated,
     * the state is set to {@link FailedCompletedInboundState} and a
     * SIP 487 response is sent.
     */
    public synchronized void handleAbandonedStream() {
        if (log.isDebugEnabled())
            log.debug("A stream was detected abandoned in " + this + ". The call is disconnected.");

        String message = "A stream was detected abandoned. A SIP 487 response will be sent.";

        if (log.isInfoEnabled())
            log.info(message);

        // Set call to failed
        call.setStateFailed(FailedInboundState.FailedSubState.COMPLETED);
        call.fireEvent(new FailedEvent(
                call, FailedEvent.Reason.REJECTED_BY_FAR_END,
                CallDirection.INBOUND, message,
                call.getConfig().getReleaseCauseMapping().getNetworkStatusCode(null, null)));

        // Make sure the streams are deleted after the event is sent.
        // This is done to make sure that the event is generated before any
        // event generated by stream.
        call.deleteStreams();

        call.sendErrorResponse(Response.REQUEST_TERMINATED, call.getInitialSipRequestEvent(), "Abandoned stream detected.");
    }

    /**
     * Sends a SIP "Ringing" response for the initial INVITE request.
     * <p>
     * If the SIP "Ringing" response could not be sent, the error is logged,
     * an {@link ErrorEvent} is generated and the state is set to
     * {@link ErrorInboundState}.
     * @throws IllegalStateException if the SIP response could not be sent.
     */
    private void sendRingingResponse() throws IllegalStateException {
        try {
            SipResponse sipResponse = 
                    sipResponseFactory.createRingingResponse(
                            call.getInitialSipRequestEvent(),
                            null, call.getConfig().getRegisteredName(), false);
            sipMessageSender.sendResponse(sipResponse);

        } catch (Exception e) {
            call.errorOccurred("Could not send SIP \"Ringing\" response: " + e.getMessage(), false);
            throw(new IllegalStateException());
        }
    }
}
