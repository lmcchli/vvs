package com.mobeon.ntf.out.outdial.generate;

import java.util.*;
import java.io.*;

import com.mobeon.ntf.management.ManagementInfo;
import com.abcxyz.messaging.vvs.ntf.notifier.plugin.framework.INotifierNtfAdminState.AdministrativeState;
import com.mobeon.ntf.out.outdial.OdlInfo;

/**
 * Generate a state machine description from a DealyLines spec.
 * The specification is in the form  "20,40,50" and is given
 * to the program as the value for the "-delay" flag.
 * The program also takes a -waiton flag that defines events
 * that should have a waiton before going to the next state.
 * The -endsms flag gives a sms template to use when all states
 * has been passed.
 */
public class Generator {

     private int[] allCodes = {
        OdlInfo.EVENT_CODE_COMPLETED,
        OdlInfo.EVENT_CODE_INITIATED,
        OdlInfo.EVENT_CODE_NUM_BLOCKED_OLD,
        OdlInfo.EVENT_CODE_NUM_BUSY_OLD,
        OdlInfo.EVENT_CODE_NOANSWER_OLD,
        OdlInfo.EVENT_CODE_NOT_REACHABLE_OLD,
        OdlInfo.EVENT_CODE_REQUEST_TIMEOUT,
        OdlInfo.EVENT_CODE_NOT_AVAILABLE,
        OdlInfo.EVENT_CODE_SYNTAX_ERROR,
        OdlInfo.EVENT_CODE_UNRECOGNIZED,
        OdlInfo.EVENT_CODE_LIMIT_EXCEEDED,
        OdlInfo.EVENT_CODE_NUMBER_NOTEXIST,
        OdlInfo.EVENT_CODE_INVALIND_NUM,
        OdlInfo.EVENT_CODE_UNKNOWN_ERR,
        OdlInfo.EVENT_CODE_NOMAILBOX,
        // Defined codes in 600-series
        OdlInfo.EVENT_CODE_BUSY,
        OdlInfo.EVENT_CODE_CALL_NOT_ANSWERED,
        OdlInfo.EVENT_CODE_DESTINATION_NOT_REACHABLE,
        OdlInfo.EVENT_CODE_DO_NOT_DISTURB,
        OdlInfo.EVENT_CODE_NETWORK_CONGESTION,
        // Undefined codes in 600-series
        // 601, 602, 604, 605, 606, 607, 608, 609, 611,
        // 612, 615, 616, 617, 618, 619, 621, 622, 623,
        // 624, 625, 626, 627, 628, 629, 630, 631, 632,
        // 633, 634,
        // End of codes in 600-series
        OdlInfo.EVENT_CODE_DEFAULT,
        OdlInfo.EVENT_CODE_NOTIFDISABLED,
        OdlInfo.EVENT_CODE_LOCATION_FAILURE,
        OdlInfo.EVENT_CODE_CFU_ON,
        OdlInfo.EVENT_CODE_CFU_FAILURE,
        OdlInfo.EVENT_CODE_INTERRUPTED,
        OdlInfo.EVENT_CODE_PHONEON
    };

    private String delays;
    private String waitons;
    private ArrayList delayList;
    private ArrayList waitonList;
    private String endSms;
    private String outfile;
    private static String DEFAULT_FILE = "outdial-generated.cfg";

    /** Creates a new instance of Generator */
    public Generator(String delays, String waitons, String endSms,
                     String outfile)
    {
        this.delays = delays;
        this.waitons = waitons;
        delayList = makeList(delays);
        waitonList = makeList(waitons);
        this.endSms = endSms;
        if (outfile != null) {
            this.outfile = outfile;
        } else {
            this.outfile =DEFAULT_FILE;
        }
    }

    private ArrayList makeList(String data)
    {
        ArrayList result = new ArrayList();
        if (data == null) return result;
        StringTokenizer tok = new StringTokenizer(data,", ");
        while (tok. hasMoreTokens()) {
            String next = tok.nextToken();
            try {
                int itsValue = Integer.parseInt(next);
            } catch (NumberFormatException nfe) {
                System.err.println("Delays/states must be numbers. " + next +
                    " is not a number");
                ManagementInfo.get().setNtfAdministrativeState(AdministrativeState.SHUTDOWN);
            }
            result.add(next);
        }
        return result;
    }


    /**
     * Generate the state machine
     */
    public void generate()
    {
        PrintStream ps = null;
        try {
            FileOutputStream fos = new FileOutputStream(outfile);
            ps = new PrintStream(fos);
            System.out.println("Generating to file : " + outfile);
        } catch (IOException ioe) {
            System.err.println("Cannot open file : " +outfile);
            System.err.println("Generating to stdout");
            ps = System.out;
        }
        generateHeader(ps);
        generateDefaults(ps);
        generateInitialState(ps);
        for (int i = 1; i<=delayList.size(); i++) {
            generateState(ps,i);
        }
    }


    private void generateHeader(PrintStream ps)
    {
        ps.println("# --- Outdial Configuration File ---");
        ps.println("# This file is automatically generated with ");
        ps.println("# the following parameters");
        ps.println("# delays = " + delays );
        if (waitons != null) {
            ps.println("# waitons = " + waitons );
        }
        if (endSms != null) {
            ps.println("# endsms = " + endSms);
        }
        ps.println("# ----------------------------------- ");
        ps.println("# Administrative info");
        ps.println("#");
        ps.println("maxwaithours = 72");
        ps.println("initialstate = 0");
        ps.println("numberofstates = " + (delayList.size() + 1));
        if (endSms != null) {
            ps.println("longtimesms = " + endSms);
        }
    }

    private void generateDefaults(PrintStream ps)
    {
        ps.println("# ----------------------------------- ");
        ps.println("# Default Transitions ");
        ps.println("# Good calls");
        ps.println("default." + OdlInfo.EVENT_CODE_COMPLETED + "=END/");
        ps.println("default." + OdlInfo.EVENT_CODE_INITIATED + "=END/");
        ps.println("# Quit at once for unrecoverable errors");
        for (int i=0; i<allCodes.length; i++) {
            int code = allCodes[i];
            if ((code >= 500) && (code < 600)) {
                ps.println("default." + code + "=END/");
            }
        }
        ps.println("# Busy always restarts");
        String busyCodeOld = "" + OdlInfo.EVENT_CODE_NUM_BUSY_OLD;
        String busyCode = "" + OdlInfo.EVENT_CODE_BUSY;
        ps.println("default." + busyCodeOld + "=1/wait " +
                   delayList.get(0) + "; call");
        ps.println("default." + busyCode + "=1/wait " +
                   delayList.get(0) + "; call");
        ps.println();
    }

    private void generateInitialState(PrintStream ps)
    {
        ps.println("# --------------------------------- ");
        ps.println("# Initial state ");
        String cmd = "";
        String startCode = "" +OdlInfo.EVENT_CODE_DEFAULT;
        if (waitonList.contains(startCode)) {
            cmd = "waiton;";
        }
        cmd += "wait " + delayList.get(0) + ";call";
        ps.println("state.0." + startCode + "=1/" + cmd);
        ps.println();
    }

    /**
     * Generate transitions for one state.
     */
    private void generateState(PrintStream ps,int stateNo)
    {
        ps.println("# ----------------------------- ");
        ps.println("# State " + stateNo );

        boolean nextIsEnd = stateNo == delayList.size();
        //
        // If this is the last state all transitions go to END
        // and we should have an sms if that is wanted
        // If there are more states temporary errors and ESI
        // problems go there after a wait and possible a phoneon.
        //
        String nextState = "" + (stateNo + 1);
        if (nextIsEnd) nextState = "END";

        for (int i = 0; i < allCodes.length; i++) {
            int code = allCodes[i];
            if ((code < 400) || (code == OdlInfo.EVENT_CODE_NUM_BUSY_OLD)
                || (code == OdlInfo.EVENT_CODE_BUSY)
                || ((code >= 500) && (code <= 599) )
                || ((code >= 700) && (code < 900) )
                || (code == OdlInfo.EVENT_CODE_DEFAULT ) ){
                    continue;
            }

            String stateevent = "state." + stateNo + "." + code;
            String transition = "";
            if (nextIsEnd) {
                if (endSms != null) {
                    transition="sms " + endSms;
                }
            } else {
                // Since we does a waiton we probably does not need
                // to wait as long as the basic wait time, chose the
                // first delaytime instead of where we are.
                if (waitonList.contains("" + code)) {
                    transition = "waiton; wait " + delayList.get(0) + ";";
                } else {
                    transition = "wait " + delayList.get(stateNo) + ";";
                }
                transition += " call";
            }
            ps.println(stateevent + "=" + nextState + "/" + transition);
        }

        // Add a default transition from this state
        String defaultTransition = "";
        if (nextIsEnd) {
            if (endSms != null) {
                defaultTransition = "sms " + endSms;
            }
        } else {
            defaultTransition = "wait " + delayList.get(stateNo) + "; call";
        }
        ps.println("state." + stateNo + ".default = " +
                   nextState + "/" + defaultTransition);

    }


    public static void usage()
    {
        System.err.println("usage: generate -d delays " +
            "[-w waitons] [-e endsms] [-f outfile]");
        System.err.println("  delays = comma-separated list of waittimes ");
        System.err.println("           should be same as config of" +
                           " delaylines");
        System.err.println("  waitons = comma-separated list of events" );
        System.err.println("            that should require a SMS0 before ");
        System.err.println("            continuing default is none");
        System.err.println("            Include 900 in this list to get a " );
        System.err.println("            waiton when starting outdial");
        System.err.println("  endsms = If this is specified an SMS with this");
        System.err.println("           template is sent when the state " +
                                       "machine reaches final state ");
        System.err.println("           without a successful call.");
        System.err.println("  outfile = File to generate state machine to " );
        System.err.println("            If not given the default name " );
        System.err.println("            " + DEFAULT_FILE + " is used");

        ManagementInfo.get().setNtfAdministrativeState(AdministrativeState.SHUTDOWN);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)
    {
       if (args.length % 2 != 0)usage();
       String delay = null;
       String waitons = null;
       String endsms = null;
       String outfile = null;
       for (int i=0; i<args.length; i+= 2) {
           String flag = args[i];
           if (flag.charAt(0) != '-') usage();
           if (flag.equals("-d")) {
               delay = args[i+1];
           } else if (flag.equals("-w")) {
               waitons = args[i+1];
           } else if (flag.equals("-e")) {
               endsms = args[i+1];
           } else if (flag.equals("-o")) {
               outfile = args[i+1];
           } else {
               usage();
           }
       }
       if (delay == null) usage();
       Generator gen = new Generator(delay, waitons, endsms, outfile);
       gen.generate();


    }

}
