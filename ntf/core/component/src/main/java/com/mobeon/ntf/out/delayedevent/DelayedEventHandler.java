/* COPYRIGHT (c) Abcxyz Communications Inc. Canada (EMC), 2015.
 * All Rights Reserved.
 *
 * The copyright to the computer program(s) herein is the property
 * of Abcxyz Communications Inc. Canada (EMC). The program(s) may
 * be used and/or copied only with the written permission from
 * Abcxyz Communications Inc. Canada (EMC) or in accordance with
 * the terms and conditions stipulated in the agreement/contract
 * under which the program(s) have been supplied.
 */

package com.mobeon.ntf.out.delayedevent;

import java.util.Properties;

import com.abcxyz.messaging.common.oam.LogAgent;
import com.abcxyz.messaging.vvs.ntf.notifier.plugin.framework.schedule.INotifierEventInfo;
import com.abcxyz.services.moip.ntf.coremgmt.DelayedEventTriggerHandler;
import com.abcxyz.services.moip.ntf.coremgmt.oam.NtfCmnLogger;
import com.abcxyz.services.moip.ntf.event.DelayedEvent;
import com.abcxyz.services.moip.ntf.event.DelayedEvent.ActionType;
import com.abcxyz.services.moip.ntf.event.DelayedEventFactory;
import com.abcxyz.services.moip.ntf.event.NtfEvent;
import com.mobeon.common.trafficeventsender.TrafficEventSenderException;
import com.mobeon.common.trafficeventsender.mfs.IMfsEventManager;
import com.mobeon.common.trafficeventsender.mfs.MfsEventFactory;
import com.mobeon.common.trafficeventsender.mfs.MfsEventManager;
import com.mobeon.ntf.Config;
import com.mobeon.ntf.Constants;
import com.mobeon.ntf.NotificationGroup;
import com.mobeon.ntf.management.ManagedLinkedBlockingQueue;
import com.mobeon.ntf.userinfo.UserInfo;


/**
 * This class <code>DelayedEventHandler</code> holds delayedEventsQueue, starts the delayedEventWorkers threads, and handles the delayedevent
 * coming from {@link com.mobeon.ntf.NotificationHandler#handleDelayedEvent(UserInfo, NotificationGroup)}, either it is of action start
 * or cancel
 *
 * @author ewenxie
 * @author lmcmajo
 * @see com.mobeon.ntf.NotificationHandler
 * @see com.mobeon.ntf.out.delayedevent.DelayedEventWorker
 * @see com.abcxyz.services.moip.ntf.coremgmt.DelayedEventTriggerHandler
 *
 * @since vfe_nl33_mfd02  2015-07-14
 */
public class DelayedEventHandler implements Constants {
    private static LogAgent log = NtfCmnLogger.getLogAgent(DelayedEventHandler.class);
    private ManagedLinkedBlockingQueue<INotifierEventInfo> delayedEventsQueue;
    private DelayedEventTriggerHandler delayedEvtTriggerHandler;
    private static DelayedEventHandler instance = null;
    private DelayedEventWorker[] delayedEventWorkers;

    /**
     * Indicates whether the delayed event handling service is started. It will be false if the number of DelayedEventWorker
     *  threads is configured as 0.
     */
    private boolean isStarted = false;
    private IMfsEventManager mfsEventManager = null;
    public static final String DELAYED_EVENT_ID = "DlydEvtId"; //for storing persistently the eventId generated by scheduler in a status file

    private DelayedEventHandler(){
        // Create delayed event workers
        int numberOfWorkers = Config.getDelayedEventWorkers();
        if (numberOfWorkers > 0) {
            mfsEventManager = MfsEventFactory.getMfsEvenManager();
            // Create working queue
            delayedEventsQueue = new ManagedLinkedBlockingQueue<INotifierEventInfo>(Config.getDelayedEventQueueSize());

            delayedEvtTriggerHandler = DelayedEventTriggerHandler.get();
            delayedEvtTriggerHandler.setDelayedEventsQueue(delayedEventsQueue);

            delayedEventWorkers = new DelayedEventWorker[numberOfWorkers];
            for(int i = 0; i < numberOfWorkers; i++){
                delayedEventWorkers[i] = new DelayedEventWorker(delayedEventsQueue, "DelayedEventWorker-" + i, this);
                delayedEventWorkers[i].setDaemon(true);
                delayedEventWorkers[i].start();
            }
            isStarted = true;

        }
        else{
            log.warn("Won't start DelayedEventWorker threads because the number of DelayedEventWorker is configured as " + numberOfWorkers);
        }

    }

    /**
     * The method handles the delayedevent coming from NotificationHandler. If the action is <i>start</i>, it will call
     * {@link com.abcxyz.services.moip.ntf.coremgmt.DelayedEventTriggerHandler#scheduleDelayedEvent(DelayedEvent)} to schedule
     * the delayedevent; if the action is <i>cancel</i>, it will cancel the previously scheduled delayedevent, if it still exists.
     *
     * @param   user  for whom this delayedevent is for.
     * @param   ng    used to feedback the handling results
     * @return  0 if the handling result is failed or retry, and 1 if the handling result if ok.
     */
    public int handleDelayedEvent(UserInfo user, NotificationGroup ng){
        log.debug("Entering into handleDelayedEvent()");
        int count = 0;
        if (!isStarted) {
            log.error("Received delayedevent, but the service is not started");
            ng.retry(user, NTF_DELAYED_NOTIFY, "The service is not yet started");
            return count;
        }

        NtfEvent ntfEvent = ng.getEmail().getNtfEvent();
        DelayedEvent delayedEvent = DelayedEventFactory.createDelayedEvent(ntfEvent.getEventProperties());
        if (delayedEvent == null) {
            ng.failed(user, NTF_DELAYED_NOTIFY, "Invalid DelayedEvent.");
            return count;
        }

        ActionType action = delayedEvent.getAction();
        if ( action == ActionType.CANCEL) {
            if (!cancelDelayedEvent(delayedEvent)) {
                ng.retry(user, NTF_DELAYED_NOTIFY, "Unable to cancel delayedevent, will retry");
                return count;
            }

            ng.ok(user, NTF_DELAYED_NOTIFY);
            return ++count;
        }
        else if (action == ActionType.START) {
//            if(delayedEvent.getTriggerTime().getTime() <= System.currentTimeMillis()){
//                //This may happen if the MAS couldn't send the delayed event to NTF for a long time
//                log.warn("The " + DelayedEvent.TRIGGER_TIME + " " + delayedEvent.getTriggerTime() + " is in the past!" );
//                //FIXME: needs to be configurable to do now or fail, maybe in the traffic event itself.
//                //The easiest way would be to schedule with a zero delay, just the retry will kick and send it.
//                //Decision: later is better than never, so send the reminder NOW.
//                ng.failed(user, NTF_DELAYED_NOTIFY, "The delayed event is in the past");
//                return count;
//            }

            if ( mfsEventManager.fileExists(user.getTelephoneNumber(), delayedEvent.getStatusFileName(), true)) {
                //This could happen in very rare situations, that a cancel action comes before this start action,
                //but doesn't get processed before this start action.
                log.warn("DelayedEvent had already been scheduled for " + user.getTelephoneNumber() + ", so ignoring this one");
                ng.ok(user, NTF_DELAYED_NOTIFY);
                return ++count;
            }

            String eventId = delayedEvtTriggerHandler.scheduleDelayedEvent(delayedEvent);
            if (eventId != null) {
                if (!updateSchedulerEventIdPersistenty(user.getTelephoneNumber(), eventId, delayedEvent.getStatusFileName())) {
                    ng.retry(user, NTF_DELAYED_NOTIFY,
                            "The delayedevent can't be scheduled because the status file can't be updated at this time.");
                    return count;
                }

                log.debug("The delayedevent is scheduled successfully, the eventId is " + eventId);
                ng.ok(user, NTF_DELAYED_NOTIFY);
                return ++count;
            } else {
                log.debug("The delayedevent can't be scheduled. The level 2 backup will be cancelled");
                ng.failed(user, NTF_DELAYED_NOTIFY, "The delayedevent can't be scheduled");
            }
        } else {
            log.warn("Unknown action: " + action.action() + " for delayedevent of type " + delayedEvent.getDelayedEventType().type() + " for " + user.getTelephoneNumber());
            ng.failed(user, NTF_DELAYED_NOTIFY, "Unknown action");
        }

        return count;
    }

    /**
     * Update the subscriber's delayed event related status file (create this file is necessary) with a new eventId,
     * if the eventId is null, remove the status file if it exists.
     *
     * @param   telephoneNumber   indicates the subscriber whose status file will be updated.
     * @param   eventId           the eventId that should be written into the status file
     * @param   statusFileName    the status file name
     * @return  true if the status file is successfully updated or removed, otherwise return false.
     */
    protected boolean updateSchedulerEventIdPersistenty(String telephoneNumber, String eventId, String statusFileName) {
        if (!mfsEventManager.isStorageOperationsAvailable(telephoneNumber, telephoneNumber)) {
            return false; // cannot update while read only.
        }
        if (eventId == null || eventId.isEmpty()) {
            return removeStatusFile(telephoneNumber, statusFileName);
        }
        try {
            Properties properties = new Properties();
            properties.put(DELAYED_EVENT_ID, eventId);
            mfsEventManager.storeProperties(telephoneNumber, statusFileName, properties);
        } catch (TrafficEventSenderException e) {
            log.info("Unable to store scheduled event status to file " + statusFileName + " for " + telephoneNumber);
            delayedEvtTriggerHandler.cancelDelayedEvent(eventId);
            return false;
        }
        return true;
    }

    protected boolean removeStatusFile(String telephoneNumber, String statusFileName) {
        if (!mfsEventManager.fileExists(telephoneNumber, statusFileName, true)) {
            return true; // already deleted.
        }
        try {
            mfsEventManager.removeFile(telephoneNumber, statusFileName, true);
            return true;
        } catch (TrafficEventSenderException e) {
            log.debug("Failed to remove Status file: " + statusFileName + " for " + telephoneNumber);
            return false;
        }

    }

    /**
     * Cancels the scheduled next retry event if it exists. And removes the corresponding status file if it exists.
     *
     * @param delayedEvent from which the status file will be determined.
     * @return true if the status file doesn't exist, or it exists and the scheduled next retry event is cancelled and
     *          the status file is removed successfully; otherwise returns false.
     */
    protected boolean cancelDelayedEvent(DelayedEvent delayedEvent) {
        String telNumber = delayedEvent.getSubscriberNumber();
        String statusFile = delayedEvent.getStatusFileName();
        if (!mfsEventManager.isStorageOperationsAvailable(telNumber, telNumber)) {
            return false; //cannot update while read only.
        }

        log.debug("Attempt to cancel a previously scheduled DelayedEvent.");
        Properties schdProps = mfsEventManager.getProperties(telNumber, statusFile);
        if (schdProps != null) {
            String eventId = schdProps.getProperty(DELAYED_EVENT_ID);
            delayedEvtTriggerHandler.cancelDelayedEvent(eventId);
            return removeStatusFile(telNumber, statusFile);
        } else {
            log.debug("No event to cancel for  " + delayedEvent.getEventProperties() + ", " + statusFile + " for " + telNumber
                    + " doesn't exist, this could happen when the previously scheduled delayedevent was fired and processed.");
            return true;
        }
    }

    public static DelayedEventHandler get(){
        if(instance == null){
            instance = new DelayedEventHandler();
        }
        return instance;
    }

    public boolean isStarted()
    {
        return  isStarted;
    }


    /**
     * Check whether the eventId in the fired eventInfo matches with the one stored in the subscriber's status file. If they don't
     * match, then the scheduled next retry event will be cancelled.
     *
     * @param delayedEvent which will be used to determine the subscriber's status file.
     * @param eventInfo the event fired from scheduler.
     * @return true if the eventId matches, otherwise return false.
     */
    protected boolean doesPersitentIdMatchEventId(DelayedEvent delayedEvent, INotifierEventInfo eventInfo) {

        String statusFile = delayedEvent.getStatusFileName();

        Properties props = mfsEventManager.getProperties(delayedEvent.getSubscriberNumber(), statusFile);
        if (props == null) {
            log.debug("doesPersitentIdMatchEventId: No status file " + statusFile +  " found for " + delayedEvent.getMessageEventProperties() + ", will cancel scheduled retry event.");
            delayedEvtTriggerHandler.cancelDelayedEvent(eventInfo.getNextEventId()); //cancel scheduled retry event;
            return false;
        }

        String persistentId = props.getProperty(DELAYED_EVENT_ID);
        if (!eventInfo.isEventIdsMatching(persistentId)) {
            log.debug("doesPersitentIdMatchEventId: EventId does not match: " + delayedEvent.getMessageEventProperties() + ", will cancel scheduled retry event.");
            delayedEvtTriggerHandler.cancelDelayedEvent(eventInfo.getNextEventId()); //cancel scheduled retry event;
            return false;
        }
        return true;
    }

}
